\chapter{Implementación del sistema.}
\label{cap: capitulo_5}

A lo largo de este capítulo vamos a explicar cómo hemos llevado a cabo el proceso de implementación del sistema, partiendo del diseño especificado en las páginas anteriores.

Todos los bloques se han implantado con una filosofía similar, teniendo en cuenta que nos dirigimos a un sistema empotrado, de prestaciones limitadas, y donde la seguridad y el tiempo de respuesta son cruciales.

Debemos tener también en cuenta que el servicio podrá ser utilizado por varios usuarios a la vez ---incluso varios componentes--- y el planificador, si bien no requiere características de tiempo-real estricto, es necesario que responda adecuadamente a los tiempos marcados por la partitura.

En el demonio, nuestra máxima prioridad será la eficiencia, mientras que en la interfaz \textit{web} nos centraremos en la accesibilidad.

\section{Planificación}

\section{Servicio del reproductor}

Este bloque compone el \textit{back-end} del sistema. Comprende una gran cantidad de elementos técnicos y hace uso de numerosas funciones del sistema operativo. Vamos a escribirlo casi por completo en lenguaje C, por las siguientes razones:

\begin{enumerate}
	\item Alta calidad y eficiencia.
	\item Cercanía al \textit{hardware}.
	\item Capacidad para hacer llamadas al sistema Linux.
	\item Posibilidad de acceder al código ensamblador para hacer optimizaciones.
\end{enumerate}

Aunque todos los ejecutables se van a compilar desde código \textit{C}, haremos uso de \textit{shell-scripts} y un \textit{Makefile} que nos permitirá compilar fácilmente las fuentes e instalar los ejecutables.

En ciertos componentes, necesitaremos hacer \textbf{prototipos} para estudiar su funcionamiento y realizar pruebas de concepto, antes de implantarlos definitivamente. Esto lo haremos en Python, un lenguaje interpretado y de programación más ágil que C.

En resumen, utilizaremos el siguiente procedimiento con los componentes más complejos, que así lo requieran:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/prototipado}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:prototipado} Esquema de prototipado.}
\end{figure} 

\smallskip

El código hace uso de los siguientes componentes externos:

\begin{enumerate}
	\item Biblioteca estándar de C \cite{cplusplus}.
	\item Interfaz \acrshort{POSIX} \cite{wiki_posix}.
	\item Llamadas al sistema Linux \cite{manpages}.
	\item Sistema de archivos especial \textit{GPIOFS} \cite{gpiofs}.
	\item Biblioteca \textit{WiringPi} (solo para el modo Ingeniería) \cite{wiringpi}.
	\item Biblioteca estándar de Python (para los prototipos) \cite{python}.
\end{enumerate}

\subsection{Descodificador de MIDI}

Este fue el primer módulo a implementar. Estudiado el análisis, el diseño es sencillo por la independencia entre eventos. Sin embargo, la implementación presentaba una complejidad notable, sobre todo porque no hay un carácter separador entre eventos, y tanto los meta-eventos como las marcas de duración tienen longitud variable.

Como ya indicamos en la sección \ref{sec:fmto_midi}, el protocolo \acrshort{MIDI} especifica que los valores numéricos se indican en \textit{big-endian}. Como el procesador del \textit{Raspberry} funciona en \textit{little-endian}, hay que intercambiar los \textit{bytes} de los números que ocupen más de un \textit{byte}. La figuras siguientes ilustran este problema:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/3]{capitulo5/big_endian}
		\includegraphics[width=\linewidth/3]{capitulo5/little_endian}
		\par\end{centering}
	\smallskip
	\caption[Big-endian y little-endian]{\label{fig:endianness} Big-endian (izquierda) y little-endian (derecha). \cite{wiki_endianness}}
\end{figure}
	
\smallskip

Por otro lado, también sabemos que ciertos valores, como el \textit{delta} de cada evento o el tamaño de datos de los meta-eventos, son de longitud variable: cada \textit{byte} tiene un significando de 7 \textit{bits}, los menos significativos. Mientras el último \textit{bit} sea 1, entonces el \textit{byte} siguiente del archivo corresponde, de igual forma, a otros 7 \textit{bits}, que se colocarían a la derecha (menos significativos).

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/varlen}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:varlen} Campo de longitud variable.}
\end{figure}

\smallskip

Además, podemos ver que todos los tipos de evento se numeran a partir de $80_{16}$, o sea, su \textit{bit} más significativo es 1. Si el analizador buscara un tipo de evento y encontrara un valor por debajo de este número, significa que el archivo está obviando el tipo de evento, y está indicando los parámetros ---cuyo tope es 127---.

\subsubsection{Prototipo}

En primer lugar hacemos una implementación sencilla en Python, que nos permita comprobar que hemos aplicado correctamente los conceptos.

Todos los valores de los tipos enumerados se hacen mediante constantes. Tal como dicta el diseño, la clase principal es \code{MidiFile}, que recibe un nombre de archivo. Los métodos se han implementado de la siguiente forma:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, pathname)}]
	Constructor: crea un archivo \acrshort{MIDI} completo desde un nombre de archivo (\code{pathname}). Abre el archivo, desempaqueta la cabecera y escribe los atributos del objeto en consecuencia. A continuación, inicializa la lista de pistas llamando al constructor de \code{MidiTrack} tantas veces como pistas indica el archivo.
	
	\item[\code{\_\_len\_\_(self)}]
	Devuelve el tamaño de la lista de pistas.
	
	\item[\code{\_\_getitem\_\_(self, key)}]
	Devuelve la pista indicada (\code{key}).
	
\end{description}

De esta forma, un archivo es sustancialmente una lista de pistas, y define los siguientes métodos:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, file)}]
	Constructor: crea una pista a partir de un fichero abierto (\code{file}), cuyo puntero debe estar al inicio de una nueva pista. Análogamente al constructor de \code{MidiFile}, analiza la cabecera, comprueba que sea válida y genera una lista de eventos utilizando para ello \code{MidiEvent.parseEvent()}
	
	\item[\code{\_\_iter\_\_(self)}]
	Permite iterar sobre los eventos la pista, devolviendo un iterador de la lista de eventos.	
\end{description}

Otra de las clases a implementar es \code{MidiEvent}, que representa cada uno de los eventos contenidos en un archivo, y contiene los siguientes métodos:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, delta, value, param1, param2)}]
	Constructor: crea un evento \acrshort{MIDI}, copiando en el sujeto (\code{self}) el retardo temporal (\code{delta}), el tipo de evento, junto al canal (\code{value}) y los parámetros (\code{param1} y \code{param2}).
	
	\item[\code{\_\_repr\_\_(self)}]
	Devuelve una cadena que expresa la representación del objeto, de la siguiente forma:
	
	\begin{center}
		<delta>: Event <tipo>@<canal> ( <Parámetro 1>, <Parámetro 2> )
	\end{center}
	
	\item[\code{note(self)}]
	Devuelve el código de nota (primer parámetro).
	
	\item[\code{velocity(self)}]
	Devuelve la intensidad sonora (primer parámetro).
	
	\item[\code{aftertouch(self)}]
	Devuelve la variación de intensidad, sita en el segundo parámetro si el tipo es \code{NOTE\_AFTERTOUCH} o en el primero en otro caso.
	
	\item[\code{controller(self)}]
	Devuelve el número de controlador (primer parámetro).
	
	\item[value\code{(self)}]
	Devuelve el valor del controlador (segundo parámetro).
	
	\item[program\code{(self)}]
	Devuelve el código de programa (primer parámetro).
	
	\item[pitch\code{(self)}]
	Devuelve el valor del \textit{pitch-bend} uniendo los parámetros:
	
	\begin{center}
		$p_1 \; | \; (p_2 << 7)$
	\end{center}
	
	\item[parseEvents(file)]
	Método de clase. Analiza todos los eventos de la pista actual en el archivo (\code{file}) hasta encontrar el meta-evento \code{END\_OF\_TRACK}. Su funcionamiento es el siguiente:
	
	\smallskip
	
	\begin{figure}[H]
		\noindent \begin{centering}
			\includegraphics[width=\linewidth*2/3]{capitulo5/flujo_parser}
			\par\end{centering}
		\smallskip
		\caption{\label{fig:flujo_parser} Diagrama de flujo del analizador.}
	\end{figure}
	
	\smallskip
	
	\item[\code{varlen(file)}]
	Es una función auxiliar privada que recibe el archivo (\code{file}) apuntando a un campo de longitud variable (véase la figura \ref{fig:varlen}) y devuelve su valor.
	
\end{description}

Por último, la clase \code{MetaEvent} hereda de \code{MidiEvent} y, de acuerdo al diseño, tiene los siguientes métodos:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, delta, evtype, data)}]
	Constructor. Crea un metaevento copiando en el sujeto (\code{self}) el retardo temporal (\code{delta}), el tipo de meta-evento (\code{evtype}) y la cadena de datos (\code{data}).
	
	\item[\code{\_\_repr\_\_(self)}]
	Devuelve una cadena que expresa la representación del objeto, de la siguiente forma:
	
	\begin{center}
		<delta>: Meta-event <tipo>@<canal> ( <Parámetro 1>, <Parámetro 2> )
	\end{center}
	
	\item[\code{number(self)}]
	Devuelve el número de secuencia (primer \textit{byte} de la cadena).
	
	\item[\code{text(self)}]
	Devuelve la propia cadena de texto.
	
	\item[\code{channel(self)}]
	Devuelve el canal por defecto (primer \textit{byte} de la cadena).
	
	\item[\code{tempo(self)}]
	Calcula el \textit{tempo} en \textit{$\mu s / \quarternote$}. Este valor ocupa 3 \textit{bytes}, que se acuñan así:
	
	\begin{center}
		($d_0 << 16) \; | \; (d_1 << 8) \; | \; d_2$
	\end{center}
	
	\item[\code{offset(self)}]
	Devuelve el desplazamiento temporal en una lista con el siguiente contenido:
	
	\begin{enumerate}
		\item Velocidad, según los 2 \textit{bits} más significativos del primer \textit{byte} de la cadena:
		
		\begin{itemize}
			\item $d_0[7:6] = 0 \Rightarrow 24 \; fps$
			\item $d_0[7:6] = 1 \Rightarrow 25 \; fps$
			\item $d_0[7:6] = 2 \Rightarrow 30 \; fps$
		\end{itemize}
		
		\item Número de horas ($d_0[5:0]$).
		\item Número de minutos ($d_1$).
		\item Número de segundos ($d_2$).
		\item Número de cuadros ($d_3$).
	\end{enumerate}
	
	\item[\code{time(self)}]
	Devuelve la marca de compás en una lista, de la siguiente forma:
	
	\begin{enumerate}
		\item Numerador: $d_0$.
		\item Denominador: $2^{d_1}$.
		\item Número de \textit{ticks} entre cada marca del metrónomo: $d_2$.
		\item Subdivisión, en \textit{fusas / click}: $d_3$.
	\end{enumerate}
	
	\item[\code{key(self)}]
	Devuelve la tonalidad en una lista, con los siguientes valores:
	
	\begin{enumerate}
		\item Número de $\sharp$ si es positivo, o número de $\flat$ si es negativo: $d_0$.
		\item Modo: $d_1$
	\end{enumerate}
\end{description}

Ya que es una prueba de concepto, el analizador emitirá un \textit{log} con  todos los datos extraídos de un archivo. Un ejemplo de salida es el siguiente:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/cap_parser}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:cap_parser} Salida del prototipo del analizador.}
\end{figure}

\smallskip

\subsubsection{Implementación final}

Una vez puesto a prueba el analizador de \acrshort{MIDI} en Python, lo pasamos a C. Al ser un lenguaje no orientado a objetos, hay que introducir algunos cambios, pero el algoritmo es el mismo que el del prototipo. Sin embargo, las funciones no diferirán mucho del lenguaje anterior, porque en Python hay que poner el sujeto del método como primer parámetro, y en la nueva implementación haremos lo mismo. La diferencia más significativa es que tendremos que insertar un \textbf{destructor}.

En primer lugar, definimos los \textbf{tipos enumerados}:

\begin{description}
	\item[\code{enum format\_t}] Formato del archivo:
	
	\begin{description}
		\item[\code{SINGLE\_TRACK}] Una sola pista.
		\item[\code{MULTIPLE\_INDEPENDENT}] Varias pistas, simultáneas.
		\item[\code{MULTIPLE\_SIMULTANEOUS}] Varias pistas, independientes.
	\end{description}
	
	\item[\code{enum division\_t}] Unidad de medida de la división de tiempo:
	
	\begin{description}
		\item[TICKS\ PER\ BEAT] La división se especifica en \textit{ticks}/\quarternote.
		\item[FRAMES\_PER\_SECOND] La división se especifica en \textit{ticks/fotograma}.
	\end{description}
	
	\item[\code{enum midievent\_type\_t}] Tipo de evento \acrshort{MIDI}. Se enumeran en la tabla \ref{tab:midi_eventos}.
	\item[\code{enum metaevent\_type\_t}] Tipo de meta-evento. Se enumeran en la tabla \ref{tab:midi_metaeventos}.
	
	\item[\code{enum midimode\_t}] Modo tonal:
	
	\begin{description}
		\item[MAJOR] Modo mayor.
		\item[MINOR] Modo menor.
	\end{description}
\end{description}

Aparte del resto de transformaciones obvias, en pro de la velocidad de ejecución, hacemos los siguientes cambios:

\begin{enumerate}
	\item Anteponemos un \textbf{prefijo} a las funciones propias de cada estructura. El primer parámetro de todas ellas será un puntero a la misma.
	
	\item Eliminamos las funciones de consula que acceden llanamente a los parámetros, y a cambio sustituimos los parámetros simples por \textbf{uniones} con los nombres de las funciones.
	
	\item Ya que no podemos conocer a \textit{priori} el número de eventos que contendrá una pista, vamos a interpretar la composición propuesta por el diagrama \ref{fig:uml_midi} como una \textbf{lista enlazada} de eventos. Ya que la inserción y la lectura van a ser secuenciales, garantizamos una eficiencia algorítmica $O(1)$ en cada acceso.
\end{enumerate}

\subsection{Planificador}

El planificador es la parte más crítica del sistema: debe cronometrar y ejecutar los eventos del archivo que está abierto, y atender a las llamadas declaradas en la interfaz.

El procedimiento básico es sencillo: cada evento tiene una marca de tiempo respecto al evento anterior. El sistema debe "dormir" el tiempo indicado ejecutar el evento, y avanzar al siguiente, hasta la marca de fin de pista.

Solo vamos a atender cuatro tipos de evento:

\begin{enumerate}
	\item Evento NOTE\_ON, para activar una nota.
	\item Evento NOTE\_OFF, para desactivar una nota.
	\item Metaevento TEMPO, para establecer la velocidad.
	\item Metaevento END\_OF\_TRACK, para terminar.
\end{enumerate}

\subsubsection{Prototipo}

De la misma forma que hicimos con el descodificador de archivos \acrshort{MIDI}, vamos a escribir un prototipo sencillo en Python. Recibirá un objeto de la clase \code{MidiFile} e interpretará una de sus pistas, a fin de estudiar la salida y hacer ajustes si es necesario.

El algoritmo se estructurará según el siguiente diagrama:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo5/flujo_planificacion}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:flujo_planificacion} Diagrama de flujo del planificador (simple).}
\end{figure}

\smallskip

En este caso, implementamos la clase \code{Instrument} para abstraernos de la configuración del instrumento, que tendrá que definir mínimamente algunas funciones de la interfaz de salida:

\begin{description}[style=nextline]
	\item[\code{state}]
	Estado del instrumento. Almacena qué notas están activas y cuáles inactivas. En lugar de una lista de \textit{booleanos}, será un simple número entero que trataremos como un campo de \textit{bits}, correspondiendo el más significativo a la nota más aguda, y el \textit{bit} menos significativo a la tecla más grave.
	
	\item[\code{length}]
	Especifica el número de notas que admite nuestro instrumento. Será el ancho del campo de \textit{bits}.
	
	\item[\code{offset}]
	Indica la primera nota del instrumento como el desplazamiento respecto a la primera nota \acrshort{MIDI}.
	
	\item[\code{\_\_init\_\_(self, length, offset}]
	Constructor. Crea las estructuras de datos en \code{self} conociendo la longitud del teclado (\code{length}) y la primera nota (\code{offset}).
	
	\item[\code{note\_on(self, note)}]
	Activa la nota indicada (\code{note}), comprobando antes si está dentro del rango cubierto por el teclado.
	
	\item[\code{note\_off(self, note)}]
	Apaga la nota indicada (\code{note}) si ésta pertenece al teclado.
	
	\item[\code{play(self, midi, track)}]
	Método del planificador. Cronometra y ejecuta la pista indicada (\code{track}) del archivo de la clase \code{MidiFile}. Esta función implementa el algoritmo que queremos prototipar.
	
\end{description}

La salida es muy simple: muestra para cada evento el cambio producido y el estado actual:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/cap_pytest}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:cap_pytest} Captura de pantalla del prototipo.}
\end{figure}

\smallskip

El prototipo nos sirvió para extraer dos objeciones:

\begin{enumerate}
	\item El retraso ($\Delta$) del evento es inversamente proporcional al \textit{tempo} y a la división de tiempo, indicada en la cabecera del archivo. Así pues, como el \textit{tempo} se expresa invertido, la espera se calcula de la siguiente forma:
	
	\begin{center}
		$retraso \; (\mu s)  = \frac{\Delta \; (ticks) \; \times \; tempo \; (\mu s / \quarternote)}{division \; (ticks / \quarternote)}$
	\end{center}
	
	\item La semántica para desactivar una nota no solo se hace con un evento NOTE\_OFF, sino que algunas piezas lo especifican con un evento NOTE\_ON con velocidad 0. Esto resulta útil para ahorrar espacio de almacenamiento, repitiendo el mismo tipo de evento.
\end{enumerate}

Una vez corregidos estos detalles, el prototipo cumple su objetivo correctamente. 

\subsubsection{Implementación final}

El paso siguiente es implantar el algoritmo en C con los correspondientes añadidos. El más importante es que, en realidad, no debemos ejecutar una pista, sino tantas como tenga el archivo. Tenemos dos alternativas:

\begin{enumerate}
	\item A cada pista se le asigna una hebra de ejecución. Se inician todas a la vez y se esperan al final.
	\item Ampliamos el algoritmo para que ejecute todas las pistas de forma síncrona.
\end{enumerate}

Como hemos podido deducir del diseño, nos decantamos por la segunda opción, considerando que todas las hebras tendrían que sincronizarse con la interfaz de salida, haciendo más llamadas de las necesarias. Además, las llamadas al sistema para retrasar la ejecución, así como las dedicadas a sincronizar la exclusión mutua, desfasarían las pistas, provocando una interpretación musical incorrecta.

Ya que el procesador del \textit{Raspberry Pi} solo tiene un núcleo, no vamos a ganar tiempo dividiendo el proceso en hebras, si sabemos manejar correctamente las pistas. Para ello, diseñamos el algoritmo descrito en la sección \ref{subsec:planificador}, que requerirá una sola hebra, que llamaremos "hebra de reproducción".

El planificador define su interfaz de la siguiente manera:

\begin{description}[style=nextline]
	\item[enum player\_state\_t]
	
	Estado interno del reproductor.

	\begin{description}
		\item[\code{PAUSED}] En pausa.
		\item[\code{PLAYING}] Reproduciendo.
		\item[\code{STOPPED}] Detenido completamente.
		\item[\code{ENGINEER}] En modo Ingeniería. No se puede reproducir.
	\end{description}

	El orden de los tipos debe hacerse cuidadosamente para permitir al compilador generar un código óptimo \cite{vikman_switch}: Si las funciones utilizan la sentencia \code{switch} con etiquetas que comparten instrucciones (no todas acaban en \code{break}), es buena práctica que las etiquetas sigan el orden en que se ha declarado la enumeración.
	
	\item[\code{int player\_start(char **playlist, int n, int loop)}]
	Inicia la hebra de reproducción. Si ésta estaba en funcionamiento, primero la detiene. En primer lugar almacena la lista de rutas de archivo (\code{playlist}), el índice de la primera pieza a ejecutar (\code{n}) y la especificación de reproducir o no en bucle (\code{loop}).
	
	Ya que la terminación de la hebra anterior pudo ser natural o forzada, esta función es la encargada de eliminar la lista de reproducción precedente, si la hubiera. Una vez hecho esto, lanza la hebra de reproducción y devuelve el código de error (normalmente 0).
	
	\item[\code{int player\_wait()}]
	
	Bloquea a la hebra llamante hasta que la hebra de reproducción termine, y devuelve siempre \code{NULL}.
	
	\item[\code{int player\_pause()}]
	
	Comprueba que la hebra está funcionando y la pausa, cambiando el estado a \code{PAUSED}. A fin de evitar la espera activa de la hebra de reproducción, utilizaremos un semáforo de sincronización, que explicaremos más abajo.
	
	Devuelve 0 si ha pausado correctamente, o -1 si no estaba en ejecución.
	
	\item[\code{int player\_resume()}]
	
	Al contrario que la función anterior, comprueba que estaba en pausa, cambia el estado a \code{PLAYING} y señala el semáforo para despertar a la hebra de reproducción. Si estaba en reproducción, no hace nada. 
	
	Devuelve 0 si se ha reanudado la reproducción (o ya estaba funcionando), o -1 si estaba detenido.
	
	\item[\code{int player\_stop()}]
	
	Provoca la detención de la hebra de reproducción cambiando el estado a \code{STOPPED}, y espera a que la hebra termine efectivamente. Si estaba en pausa, primero despierta a la hebra para que termine por sí sola.
	
	Devuelve 0 si se ha detenido correctamente. Solo devuelve -1 si estaba en modo Ingeniería.
	
	\item[\code{player\_state\_t player\_state(char *file)}]
	
	Esta función devuelve el estado actual del reproductor. En caso de que estuviera en funcionamiento o pausado, copia en el parámetro \code{file} la ruta del archivo que está reproduciendo la hebra.
	
	\item[\code{int player\_engineer\_enter()}]
	
	Entra en el modo Ingeniería cambiando el estado a \code{ENGINEER}. Si la hebra estaba iniciada, previamente la detiene completamente. Si ya está en modo Ingeniería, no hace nada.
	
	Siempre devuelve 0.
	
	\item[\code{int player\_engineer\_exit()}]
	
	Sale del modo Ingeniería, si estaba dentro de él. El estado a la salida de \code{STOPPED}. Devuelve 0 si ha salido correctamente, o -1 si no estaba dentro.
\end{description}

Además, el módulo implementa los siguientes elementos de forma \textbf{estática}. Esto, en el ámbito del lenguaje C, significa que los símbolos no se exportan y, en consecuencia, solo las funciones dentro del módulo pueden llamarlas. Es el equivalente a los métodos privados en los lenguajes orientados a objetos. Son las siguientes:

\begin{description}[style=nextline]
	\item[\code{void* player\_run(void *arg)}]
	Punto de inicio de la hebra de reproducción. Consiste sencillamente en un bucle que recorre la lista de reproducción. En cada ciclo, abre el archivo correspondiente con ayuda del módulo \acrshort{MIDI} y lo ejecuta llamando a \code{playscore()}. Si la lectura falla, se ignora el archivo. En cualquier caso, después del uso, se destruye.
	
	Si se ha marcado la ejecución en bucle, al terminar de reproducir la lista, se vuelve al principio, indefinidamente. Si se diera el (improbable) caso de que todos los archivos de la lista fallen, la hebra termina.
	
	Devuelve siempre \code{NULL} como código de retorno del subproceso.
	
	\item[\code{int playscore(midifile\_t *file)}]
	
	Implementa el algoritmo de planificación para reproducir el archivo (\code{file}). Aplica el procedimiento descrito, al que añade una comprobación de estado en cada ciclo del bucle principal:
	
	\begin{description}
		\item[\code{PLAYING}] Continúa la ejecución normalmente.
		
		\item[\code{PAUSED}] Silencia la salida (manteniendo el estado) y pausa la reproducción. Como hemos adelantado, utiliza un semáforo para evitar la espera activa. El subproceso se bloquea hasta que otra hebra llame a \code{player\_pause()}, que es la que señala dicho semáforo..
		
		\item[\code{STOPPED}] Restablece la salida (borra el estado) y sale del bucle principal. 
	\end{description}
	
	Para un rendimiento óptimo, el bucle que ejecuta inmediatamente los eventos llama a \code{output\_noteon()} y \code{output\_noteoff()}, que cambian el estado del módulo de salida pero no la exportan efectivamente al instrumento. Cuando la racha termina, se sincroniza con la salida ---\code{output\_update()}--- y realiza la espera mediante una llamada a \code{nanosleep()}.

	El método de salida queda patente por el código de retorno:
	
	\begin{description}
		\item[0] Finalización natural.
		\item[1] Finalización forzada por una llamada a \code{player\_stop()}.
	\end{description}
	
\end{description}

\subsubsection{Concurrencia}

El planificador puede ser llamado por el servidor de \textit{socket}, el controlador del mando o el gestor del modo Ingeniería en cualquier momento, y en cualquier punto del reproductor. Esto puede llegar a generar \textbf{condiciones de carrera}, o incluso bloquear el sistema si dos módulos pretenden llevar a cabo acciones al mismo tiempo.

Además, debemos tener en cuenta posibles \textbf{usos ilegales} de la hebra de reproducción, como iniciarla, pausarla o detenerla varias veces consecutivas. Para evitar esto, como hemos descrito, las funciones públicas de control comprueban el estado antes de actuar.

A fin de no provocar una condición de carrera entre la hebra de reproducción y el resto, la primera nunca cambiará el estado, incluso si la partitura ha acabado. En su lugar activa una \textbf{variable "bandera"} volátil (no afectada por optimizaciones del compilador) para ser leída por las funciones de control. Si está marcada, cambiarán automáticamente el estado a \code{STOPPED}.

Para evitar inconsistencias entre funciones públicas, todas ellas utilizarán un \textbf{\acrshort{mutex}} que monitoriza las llamadas, haciendo que toda función deba esperar a que termine cualquier otra que estuviera funcionando.

\subsection{Salida GPIO}

Esta parte del programa supone el "puente" entre el planificador y la \acrshort{PCB}, transformará instrucciones de activación y desactivación de notas en señales lógicas que emitiremos por el \acrshort{GPIO}. 

Este módulo se diseñó de forma muy flexible para que se pudiera adaptar fácilmente a cualquier órgano, o incluso se pudiera dirigir a otra interfaz, como tal vez la salida estándar ---de hecho, en el simulador de reproducción (sección \ref{subsec:simulador_reproduccion}) redefiniremos la interfaz para que así sea---.

Todas las implementaciones deben tener en común el hecho de almacenar el estado de todas las notas del instrumento. Las llamadas a \code{output\_noteon()} y \code{output\_noteoff()} cambiarán ese estado, y \code{output\_update()} volcará efectivamente esta información en la salida.

\subsubsection{Prototipo}

Inicialmente hicimos una "prueba de concepto" en Python para entender el funcionamiento de los registros de desplazamiento. Como ya explicamos en la sección de análisis (\ref{subsec:conexion_mecanica}), cada registro está dedicado a un componente del órgano, pero todos funcionan igual.

La idea es conseguir ver en los \acrshort{led}s la interpretación de una pieza conocida y fácilmente reconocible. Hemos tomado como ejemplo el famoso \textit{Himno a la alegría} de Ludwig van Beethoven:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[clip=true,trim=20 580 20 30,width=\linewidth*3/4]{capitulo5/beethoven_1voz}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:beethoven_1voz} Fragmento del Himno a la Alegría de Beethoven.}
\end{figure}

\smallskip

Ya que no tenemos notas cromáticas, y disponemos de solo 7 \textit{bits} en la \acrshort{PCB}, vamos a establecer la siguiente equivalencia:

\smallskip

\begin{center}
	\begin{tabular}{|l|l|}
		\hline Do & \code{1000000} \\ 
		\hline Re & \code{0100000} \\ 
		\hline Mi & \code{0010000} \\ 
		\hline Fa & \code{0001000} \\
		\hline Sol & \code{0000100} \\
		\hline La & \code{0000010} \\
		\hline Si & \code{0000001} \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:equiv_notas_prot} Equivalencia de notas en el prototipo.}
\end{center}

\smallskip

Cualquier acorde no sería más que una combinación de bits. Todo lo que tenemos que hacer es volcar cada nota por separado, esperar el tiempo que hagamos corresponder a una negra (\quarternote) y silenciarlo todo (volcar solo ceros). El procedimiento es muy sencillo:

\begin{enumerate}
	\item Escribir el valor de una celda del vector en el puerto \acrshort{GPIO} correspondiente.
	\item Emitir un pulso en el puerto conectado a SRCLK para desplazar y almacenar.
	\item Repetir los pasos 1 y 2 con el resto de \textit{bits}.
	\item Emitir un pulso en el puerto conectado a RCLK para copiar del registro de desplazamiento al registro de almacenamiento.
\end{enumerate}

Para emitir un pulso en el registro, actuamos de la siguiente forma, de acuerdo al manual técnico de los registros:

\begin{enumerate}
	\item Escribir "1" en el puerto llamando a \code{output()}.
	\item Esperar 100 \textit{ns} con una llamada a \code{sleep()}.
	\item Escribir "0" en el puerto.
\end{enumerate}

\subsubsection{Implementación final}

Este módulo va a ser llamado síncronamente por el planificador, por lo que todas las funciones que implementemos deben de ser tan rápidas como sea posible. El primer detalle importante es escoger una \textbf{estructura de datos} eficiente para almacenar el estado.

En este caso, todos los registros tienen el mismo tamaño, y conocemos de antemano las dimensiones, con lo cual, tenemos dos opciones. Teniendo en cuenta que hay que indizar por (nota, pista), vamos a deducir el número de operaciones necesarias para la escritura (aleatoria) y la lectura (secuencial):

\begin{enumerate}
	\item Una variable entera \textbf{como campo de \textit{bits}}.
	\begin{itemize}
		\item Cada escritura requiere: indirección + multiplicación + suma + desplazamiento + conjunción + escritura. 
		\item Cada lectura requiere: desplazamiento.
	\end{itemize}
	
	\item Una \textbf{matriz de \textit{bytes}}.
	
	\begin{itemize}
		\item Cada escritura requiere: multiplicación + suma + escritura.
		\item Cada lectura requiere: suma + indirección.
	\end{itemize}
\end{enumerate}

La matriz de \textit{bytes} está mejor equilibrada, sobre todo teniendo en cuenta que se va a hacer más escrituras que lecturas. El campo de \textit{bits}, además, nos limita a 32 \textit{bits} en total, lo que nos obligaría a hacer modificaciones cuando extendamos los registros.

Crearemos la matriz de esta manera:

\smallskip

\begin{center}
	\begin{tabular}{|c|cccc|}
		\hline & \multicolumn{4}{c|}{N pistas} \\
		\hline \multirow{7}{*}{\rotatebox[]{90}{M notas}} & $s_{0,0}$ & $s_{0,1}$ & $s_{0,2}$ & $s_{0,3}$ \\
		& $s_{1,0}$ & $s_{1,1}$ & $s_{1,2}$ & $s_{1,3}$ \\
		& $s_{2,0}$ & $s_{2,1}$ & $s_{2,2}$ & $s_{2,3}$ \\
		& $s_{3,0}$ & $s_{3,1}$ & $s_{3,2}$ & $s_{3,3}$ \\
		& $s_{4,0}$ & $s_{4,1}$ & $s_{4,2}$ & $s_{4,3}$ \\
		& $s_{5,0}$ & $s_{5,1}$ & $s_{5,2}$ & $s_{5,3}$ \\
		& $s_{6,0}$ & $s_{6,1}$ & $s_{6,2}$ & $s_{6,3}$ \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:matriz_estatica} Configuración de las notas en el estado.}
\end{center}

\smallskip

El compilador, conociendo las dimensiones, convertirá la matriz estática en un \textit{array} de la siguiente forma:

\smallskip

\begin{center}
	\begin{tabular}{|c|}
		\hline $M\times N$ \textit{bytes} \\
		\hline $s_{0,0}$ $s_{0,1}$ $s_{0,2}$ $s_{0,3}$ $s_{1,0}$ $s_{1,1}$ ... $s_{6,2}$  $s_{6,3}$ \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:matriz_estatica} Disposición física de la matriz en memoria.}
\end{center}

\smallskip

Con esta estructura, el acceso aleatorio para escribir un valor en el estado se hará con la siguiente fórmula:

\begin{center}
	$s_{nota,pista} = v_{nota \times N + pista}$
\end{center}

Para volcar la información en los registros, seguiremos los mismos pasos que en el prototipo, pero en lugar de transmitir a un puerto \acrshort{GPIO}, transmitiremos a tantos como pistas tengamos, antes de enviar el pulso a SRCLK, que desplaza las notas de todos los registros a la vez.

Hemos organizado la matriz para que la lectura se hagan en el orden estricto en que están los datos en memoria, con lo cual, en lugar de acceder a la matriz directamente y obligar al compilador a hacer una multiplicación y una suma, utilizaremos \textbf{aritmética de punteros} para movernos por ella.

\subsubsection{Acceso directo al GPIO}

La siguiente cuestión es cómo acceder al \acrshort{GPIO}. Conocemos bien el sistema de archivos especial que nos brinda Linux, pero el hecho de actuar por medio de llamadas al sistema y acceso a ficheros para algo tan elemental podría resultar ineficiente.

Los puertos \acrshort{GPIO} son pines físicos del \acrshort{SOCA}, y se puede acceder a ellos mediante el periférico correspondiente mediante acceso a memoria. Estudiando el manual del BCM2835, obtenemos la siguiente información:

\smallskip

\begin{center}
	\begin{tabular}{|l|l|}
		\hline 0x20200000 & Dirección base \\
		\hline
		\hline Base + 0 & \multirow{6}{*}{Selección de función} \\
		\cline{1-1} Base + 4 & \\
		\cline{1-1} Base + 8 & \\
		\cline{1-1} Base + 12 & \\
		\cline{1-1} Base + 16 & \\
		\cline{1-1} Base + 20 & \\
		\hline Base + 24 & Reservado \\
		\hline Base + 28 & \multirow{2}{*}{Poner a "1"} \\
		\cline{1-1} Base + 32 & \\
		\hline Base + 36 & Reservado \\
		\hline Base + 40 & \multirow{2}{*}{Poner a "0"} \\
		\cline{1-1} Base + 44 & \\
		\hline \multicolumn{2}{|c|}{...} \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:gpio_struct} Direcciones físicas del GPIO.}
\end{center}

\smallskip

El controlador de \acrshort{GPIO} utiiza registros de 32-\textit{bit}. Para obtener un puntero a una dirección de memoria física, tan solo necesitamos hacer una llamada a \code{mmap(file = "dev/mem", offset = 0x20200000)} \cite{soii}. A partir de ahí, podemos acceder a cada registro con los desplazamientos adecuados. Hay un banco de registros para poner a "1", escribiendo un 1 lógico en el \textit{bit} correspondiente al número de puerto, y otro para poner a "0", escribiendo un 1 lógico en el \textit{bit} adecuado.

De esta forma logramos la mayor eficiencia, tanto por el acceso directo a memoria como la posibilidad de escribir en todas las pistas más el reloj en una sola operación de escritura.

\subsubsection{Mapeo y tolerancia}

Huelga decir que para logar una óptima reproducción, será necesario adaptar las partituras al órgano en cuestión, ya que cada ejemplar tendrá una rango de notas y un conjunto de registros distintos. Nuestra aplicación será lo más estándar posible a la hora de leer un archivo \acrshort{MIDI}, por ello, y para evitar errores por incompatibilidad, debemos contemplar que podemos recibir un archivo \acrshort{MIDI} cualquiera.

El número de pistas y el tamaño de cada una es conocido en tiempo de compilación, como ya sabemos. Las funciones \code{output\_noteon()} y \code{output\_noteoff()} reciben el código de nota y el índice de pista, que se escribirá en el estado. Un detalle simple, pero importante, será \textbf{descartar} cualquier nota fuera del rango, y cualquier pista no declarada.

Por otro lado, no es estrictamente necesario que el orden de las pistas en el archivo (pentagramas) coincida con el orden de los registros en la \acrshort{PCB}. Para modelar esto, tendremos un \textit{array} con los números de puerto \acrshort{GPIO} asociados a cada pista del archivo \acrshort{MIDI}:

La asignación por defecto, para el órgano de prueba, será la siguiente:

\smallskip

\begin{center}
	\begin{tabular}{|l|c|c|c|c|}
		\hline \textbf{Pista} & 1 & 2 & 3 & 4 \\
		\hline \textbf{Puerto GPIO} & 02 & 03 & 17 & 04 \\
		\hline \textbf{Canal PCB} & S1 & S2 & S4 & S3 \\
		\hline \textbf{Componente} & Teclado 1 & Teclado 2 & Registros & Pedalier \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:asig_canales} Asignación de pistas al GPIO.}
\end{center}

\smallskip

\subsection{Servidor socket}



\subsection{Servidor UART}

\subsection{Modo Ingeniería}

\subsubsection{Control de salida}
\subsubsection{Control de entrada}
\subsubsection{Máquina de estados}

\subsection{Inicio del demonio}

Ahora vamos a crear el punto de inicio de nuestro servicio, para que se inicie durante el arranque del sistema operativo del \textit{Raspberry Pi}. Lo que este módulo hará será muy sencillo: iniciar todos los módulos y llamar a los bucles de escucha que incorporan en hebras diferentes.

\subsubsection{Características}

Un demonio ---en nomenclatura de la familia Unix--- es un programa que se ejecuta en segundo plano, es iniciado por el \textit{boostrap} del sistema operativo y no interactúa directamente con el usuario. Está diseñado para dar servicio a otras aplicaciones. Ni siquiera utiliza la entrada y salida estándar, en su lugar usa el registro del sistema.

Al mismo tiempo, y paradójicamente, debe terminar lo antes posible para permitir que continúe el arranque del sistema. Para iniciar correctamente el demonio, la función principal del programa recibirá el ID del usuario y del grupo con que actuará el demonio, y hará lo siguiente: \cite{shahmir_daemon}

\begin{enumerate}
	\item Crea una copia de sí mismo mediante una bifurcación, llamando a \code{fork()}. Como ya sabemos, esta función devuelve el ID del hijo al proceso padre y 0 al proceso hijo. En este punto, el padre termina.
	
	\item Crea una nueva sesión mediante \code{setsid()}, convirtiendo al proceso hijo en líder de su grupo de procesos.
	
	\item Cambia la carpeta de trabajo por la raíz del sistema, llamando a \code{chdir(''/'')}.
	
	\item Cierra mediante \code{close()} los descriptores de archivo de la entrada y salida estándar: \textit{stdin}, \textit{stdout} y \textit{stderr}.
	
	\item Abre el \textit{log} del sistema con \code{openlog()}.
	
	\item Inicia el módulo del \textit{socket}.
	
	\item Arranca el módulo del mando a distancia.
	
	\item Inicia el módulo del modo Ingeniería.
	
	\item Rebaja sus permisos a los del \acrshort{UID} y el \acrshort{GID} recibidos.
	
	\item Inicia el bucle de escucha del servidor del puerto en serie (en otra hebra).
	
	\item Llama al bucle de servicio del \textit{socket}.
	
\end{enumerate}

Otra acción importante es \textbf{programar el cierre} controlado mediante una sencilla función que detenga la reproducción y llame a las funciones de limpieza ---las que terminan en \code{\_destroy()}---:

\begin{enumerate}
	\item Planificar dicha llamada cuando se termine el programa, haciendo uso de \code{atexit}.
	\item Programar una salida normal ---\code{exit(0)}--- cuando se reciba la señal SIGTERM, que es la que envía por defecto \code{kill} y la que corresponde a pulsar Ctrl+C.
\end{enumerate}

\subsubsection{Script de arranque}

Conforme a la base estándar de Linux ---\acrshort{LSB}, \textit{\acrlong{LSB}}---, el arranque del sistema buscará un \textit{script} para iniciar el demonio en una ubicación dependiente del nivel de ejecución, y lo llamará con el argumento \code{''start''}. \cite{debian_lsbinit}

Con objeto de arrancar los distintos servicios en el orden correcto para preservar dependencias, debemos escribir una cabecera en el código, que utilizará la orden \code{insserv} para registrar el servicio. En ella especificaremos la siguiente información:

\begin{enumerate}
	\item Requiere el servicio \code{syslog}, para el \textit{log} del sistema.
	\item Se iniciará en los niveles de ejecución 2, 3, 4, 5 (multiusuario). \cite{wiki_runlevel}
	\item Se parará en los niveles 0, 1 y 6 (monousuario, apagar y reiniciar).
\end{enumerate}

El \textit{script} atenderá a las siguientes órdenes:

\begin{description}
	\item[start] Arranca el demonio. Busca el proceso con \code{ps -e | grep}, si no lo encuentra, consulta el \acrshort{UID} y \acrshort{GID} del usuario dedicado, y llama al servicio pasando ambos argumentos.
	
	\item[stop] Busca el proceso y, si lo encuentra, lo detiene con \code{kill} y espera a que haya finalizado.
\end{description}

\subsubsection{Permisos de usuario}

El demonio es llamado por el proceso \code{init} (que está empezando a ser reemplazado por \code{systemd}), por supuesto con permisos de superusuario (\textit{root}). Mantener al proceso con tales privilegios es inseguro. El servicio debe cambiar de usuario y de grupo con \code{setuid()} y \code{setgid()} cuando haya terminado de iniciar los dispositivos que requieren permisos especiales, especialmente el \acrshort{GPIO}, que mapea un puntero en memoria física.

Para manejar los permisos adecuadamente, crearemos un usuario de sistema, de uso exclusivo para el demonio. Su \acrshort{UID} y su \acrshort{GID} serán los que reciba el ejecutable al iniciar el servicio.

\subsection{Seguridad}
\subsubsection{Permisos de usuario}
\subsubsection{Conexiones simultáneas}
\subsubsection{Compatibilidad con MIDI estándar}

\subsection{Pre-instalación}

\subsection{Compilación e instalación}





\section{Interfaz web}

\subsection{Estructura principal}
\subsubsection{Plantillas}
\subsubsection{Controlador}
\subsubsection{Sesión}

\subsection{Traductor}

\subsection{Control de energía}

\subsection{Portada}
\subsubsection{Autentificación}

\subsection{Navegación}

\subsection{Conexión a la base de datos}

\subsection{Conexión al demonio}
\subsubsection{Prototipo}
\subsubsection{Implementación}

\subsection{Reproductor}
\subsubsection{Vista}
\subsubsection{Controlador}

\subsection{Gestión de listas y piezas}
\subsubsection{Vista}
\subsubsection{Controlador}

\subsection{Asignación del mando}
\subsubsection{Vista}
\subsubsection{Controlador}

\subsection{Seguridad}
\subsubsection{Inyección de código SQL}
\subsubsection{Inyección de código shell}
\subsubsection{Permisos de superusuario}


\section{Base de datos}

\section{Aplicaciones auxiliares}
\subsection{Información de archivo MIDI}
\subsection{Simulador de reproducción}
\label{subsec:simulador_reproduccion}
\subsection{Terminal del reproductor}
\subsection{Comprobación de contraseña}
\subsection{Instalador del servidor}