\chapter{Implementación del sistema.}
\label{cap: capitulo_5}

A lo largo de este capítulo vamos a explicar cómo hemos llevado a cabo el proceso de implementación del sistema, partiendo del diseño especificado en las páginas anteriores.

Todos los bloques se han implantado con una filosofía similar, teniendo en cuenta que nos dirigimos a un sistema empotrado, de prestaciones limitadas, y donde la seguridad y el tiempo de respuesta son cruciales.

Debemos tener también en cuenta que el servicio podrá ser utilizado por varios usuarios a la vez ---incluso varios componentes--- y el planificador, si bien no requiere características de tiempo-real estricto, es necesario que responda adecuadamente a los tiempos marcados por la partitura.

En el demonio, nuestra máxima prioridad será la eficiencia, mientras que en la interfaz \textit{web} nos centraremos en la accesibilidad.

\section{Planificación}

\section{Servicio del reproductor}

Este bloque compone el \textit{back-end} del sistema. Comprende una gran cantidad de elementos técnicos y hace uso de numerosas funciones del sistema operativo. Vamos a escribirlo casi por completo en lenguaje C, por las siguientes razones:

\begin{enumerate}
	\item Alta calidad y eficiencia.
	\item Cercanía al \textit{hardware}.
	\item Capacidad para hacer llamadas al sistema Linux.
	\item Posibilidad de acceder al código ensamblador para hacer optimizaciones.
\end{enumerate}

Aunque todos los ejecutables se van a compilar desde código \textit{C}, haremos uso de \textit{shell-scripts} y un \textit{Makefile} que nos permitirá compilar fácilmente las fuentes e instalar los ejecutables.

En ciertos componentes, necesitaremos hacer \textbf{prototipos} para estudiar su funcionamiento y realizar pruebas de concepto, antes de implantarlos definitivamente. Esto lo haremos en Python, un lenguaje interpretado y de programación más ágil que C.

En resumen, utilizaremos el siguiente procedimiento con los componentes más complejos, que así lo requieran:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/prototipado}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:prototipado} Esquema de prototipado.}
\end{figure} 

\smallskip

El código hace uso de los siguientes componentes externos:

\begin{enumerate}
	\item Biblioteca estándar de C \cite{cplusplus}.
	\item Interfaz \acrshort{POSIX} \cite{wiki_posix}.
	\item Llamadas al sistema Linux \cite{manpages}.
	\item Sistema de archivos especial \textit{GPIOFS} \cite{gpiofs}.
	\item \acrshort{API} para C del cliente MySQL (para el módulo de base de datos) \cite{mysql}.
	\item Biblioteca \textit{WiringPi} (solo para el modo Ingeniería) \cite{wiringpi}.
	\item Biblioteca estándar de Python (para los prototipos) \cite{python}.
\end{enumerate}

\subsection{Descodificador de MIDI}

Este fue el primer módulo a implementar. Estudiado el análisis, el diseño es sencillo por la independencia entre eventos. Sin embargo, la implementación presentaba una complejidad notable, sobre todo porque no hay un carácter separador entre eventos, y tanto los meta-eventos como las marcas de duración tienen longitud variable.

Como ya indicamos en la sección \ref{sec:fmto_midi}, el protocolo \acrshort{MIDI} especifica que los valores numéricos se indican en \textit{big-endian}. Como el procesador del \textit{Raspberry} funciona en \textit{little-endian}, hay que intercambiar los \textit{bytes} de los números que ocupen más de un \textit{byte}. La figuras siguientes ilustran este problema:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/3]{capitulo5/big_endian}
		\includegraphics[width=\linewidth/3]{capitulo5/little_endian}
		\par\end{centering}
	\smallskip
	\caption[Big-endian y little-endian]{\label{fig:endianness} Big-endian (izquierda) y little-endian (derecha). \cite{wiki_endianness}}
\end{figure}
	
\smallskip

Por otro lado, también sabemos que ciertos valores, como el \textit{delta} de cada evento o el tamaño de datos de los meta-eventos, son de longitud variable: cada \textit{byte} tiene un significando de 7 \textit{bits}, los menos significativos. Mientras el último \textit{bit} sea 1, entonces el \textit{byte} siguiente del archivo corresponde, de igual forma, a otros 7 \textit{bits}, que se colocarían a la derecha (menos significativos).

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/varlen}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:varlen} Campo de longitud variable.}
\end{figure}

\smallskip

Además, podemos ver que todos los tipos de evento se numeran a partir de $80_{16}$, o sea, su \textit{bit} más significativo es 1. Si el analizador buscara un tipo de evento y encontrara un valor por debajo de este número, significa que el archivo está obviando el tipo de evento, y está indicando los parámetros ---cuyo tope es 127---.

\subsubsection{Prototipo}

En primer lugar hacemos una implementación sencilla en Python, que nos permita comprobar que hemos aplicado correctamente los conceptos.

Todos los valores de los tipos enumerados se hacen mediante constantes. Tal como dicta el diseño, la clase principal es \code{MidiFile}, que recibe un nombre de archivo. Los métodos se han implementado de la siguiente forma:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, pathname)}]
	Constructor: crea un archivo \acrshort{MIDI} completo desde un nombre de archivo (\code{pathname}). Abre el archivo, desempaqueta la cabecera y escribe los atributos del objeto en consecuencia. A continuación, inicializa la lista de pistas llamando al constructor de \code{MidiTrack} tantas veces como pistas indica el archivo.
	
	\item[\code{\_\_len\_\_(self)}]
	Devuelve el tamaño de la lista de pistas.
	
	\item[\code{\_\_getitem\_\_(self, key)}]
	Devuelve la pista indicada (\code{key}).
	
\end{description}

De esta forma, un archivo es sustancialmente una lista de pistas, y define los siguientes métodos:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, file)}]
	Constructor: crea una pista a partir de un fichero abierto (\code{file}), cuyo puntero debe estar al inicio de una nueva pista. Análogamente al constructor de \code{MidiFile}, analiza la cabecera, comprueba que sea válida y genera una lista de eventos utilizando para ello \code{MidiEvent.parseEvent()}
	
	\item[\code{\_\_iter\_\_(self)}]
	Permite iterar sobre los eventos la pista, devolviendo un iterador de la lista de eventos.	
\end{description}

Otra de las clases a implementar es \code{MidiEvent}, que representa cada uno de los eventos contenidos en un archivo, y contiene los siguientes métodos:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, delta, value, param1, param2)}]
	Constructor: crea un evento \acrshort{MIDI}, copiando en el sujeto (\code{self}) el retardo temporal (\code{delta}), el tipo de evento, junto al canal (\code{value}) y los parámetros (\code{param1} y \code{param2}).
	
	\item[\code{\_\_repr\_\_(self)}]
	Devuelve una cadena que expresa la representación del objeto, de la siguiente forma:
	
	\begin{center}
		<delta>: Event <tipo>@<canal> ( <Parámetro 1>, <Parámetro 2> )
	\end{center}
	
	\item[\code{note(self)}]
	Devuelve el código de nota (primer parámetro).
	
	\item[\code{velocity(self)}]
	Devuelve la intensidad sonora (primer parámetro).
	
	\item[\code{aftertouch(self)}]
	Devuelve la variación de intensidad, sita en el segundo parámetro si el tipo es \code{NOTE\_AFTERTOUCH} o en el primero en otro caso.
	
	\item[\code{controller(self)}]
	Devuelve el número de controlador (primer parámetro).
	
	\item[value\code{(self)}]
	Devuelve el valor del controlador (segundo parámetro).
	
	\item[program\code{(self)}]
	Devuelve el código de programa (primer parámetro).
	
	\item[pitch\code{(self)}]
	Devuelve el valor del \textit{pitch-bend} uniendo los parámetros:
	
	\begin{center}
		$p_1 \; | \; (p_2 << 7)$
	\end{center}
	
	\item[parseEvents(file)]
	Método de clase. Analiza todos los eventos de la pista actual en el archivo (\code{file}) hasta encontrar el meta-evento \code{END\_OF\_TRACK}. Su funcionamiento es el siguiente:
	
	\smallskip
	
	\begin{figure}[H]
		\noindent \begin{centering}
			\includegraphics[width=\linewidth*2/3]{capitulo5/flujo_parser}
			\par\end{centering}
		\smallskip
		\caption{\label{fig:flujo_parser} Diagrama de flujo del analizador.}
	\end{figure}
	
	\smallskip
	
	\item[\code{varlen(file)}]
	Es una función auxiliar privada que recibe el archivo (\code{file}) apuntando a un campo de longitud variable (véase la figura \ref{fig:varlen}) y devuelve su valor.
	
\end{description}

Por último, la clase \code{MetaEvent} hereda de \code{MidiEvent} y, de acuerdo al diseño, tiene los siguientes métodos:

\begin{description}[style=nextline]
	\item[\code{\_\_init\_\_(self, delta, evtype, data)}]
	Constructor. Crea un metaevento copiando en el sujeto (\code{self}) el retardo temporal (\code{delta}), el tipo de meta-evento (\code{evtype}) y la cadena de datos (\code{data}).
	
	\item[\code{\_\_repr\_\_(self)}]
	Devuelve una cadena que expresa la representación del objeto, de la siguiente forma:
	
	\begin{center}
		<delta>: Meta-event <tipo>@<canal> ( <Parámetro 1>, <Parámetro 2> )
	\end{center}
	
	\item[\code{number(self)}]
	Devuelve el número de secuencia (primer \textit{byte} de la cadena).
	
	\item[\code{text(self)}]
	Devuelve la propia cadena de texto.
	
	\item[\code{channel(self)}]
	Devuelve el canal por defecto (primer \textit{byte} de la cadena).
	
	\item[\code{tempo(self)}]
	Calcula el \textit{tempo} en \textit{$\mu s / \quarternote$}. Este valor ocupa 3 \textit{bytes}, que se acuñan así:
	
	\begin{center}
		($d_0 << 16) \; | \; (d_1 << 8) \; | \; d_2$
	\end{center}
	
	\item[\code{offset(self)}]
	Devuelve el desplazamiento temporal en una lista con el siguiente contenido:
	
	\begin{enumerate}
		\item Velocidad, según los 2 \textit{bits} más significativos del primer \textit{byte} de la cadena:
		
		\begin{itemize}
			\item $d_0[7:6] = 0 \Rightarrow 24 \; fps$
			\item $d_0[7:6] = 1 \Rightarrow 25 \; fps$
			\item $d_0[7:6] = 2 \Rightarrow 30 \; fps$
		\end{itemize}
		
		\item Número de horas ($d_0[5:0]$).
		\item Número de minutos ($d_1$).
		\item Número de segundos ($d_2$).
		\item Número de cuadros ($d_3$).
	\end{enumerate}
	
	\item[\code{time(self)}]
	Devuelve la marca de compás en una lista, de la siguiente forma:
	
	\begin{enumerate}
		\item Numerador: $d_0$.
		\item Denominador: $2^{d_1}$.
		\item Número de \textit{ticks} entre cada marca del metrónomo: $d_2$.
		\item Subdivisión, en \textit{fusas / click}: $d_3$.
	\end{enumerate}
	
	\item[\code{key(self)}]
	Devuelve la tonalidad en una lista, con los siguientes valores:
	
	\begin{enumerate}
		\item Número de $\sharp$ si es positivo, o número de $\flat$ si es negativo: $d_0$.
		\item Modo: $d_1$
	\end{enumerate}
\end{description}

Ya que es una prueba de concepto, el analizador emitirá un \textit{log} con  todos los datos extraídos de un archivo. Un ejemplo de salida es el siguiente:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/cap_parser}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:cap_parser} Salida del prototipo del analizador.}
\end{figure}

\smallskip

\subsubsection{Implementación final}

Una vez puesto a prueba el analizador de \acrshort{MIDI} en Python, lo pasamos a C. Al ser un lenguaje no orientado a objetos, hay que introducir algunos cambios, pero el algoritmo es el mismo que el del prototipo. Sin embargo, las funciones no diferirán mucho del lenguaje anterior, porque en Python hay que poner el sujeto del método como primer parámetro, y en la nueva implementación haremos lo mismo. La diferencia más significativa es que tendremos que insertar un \textbf{destructor}.

En primer lugar, definimos los \textbf{tipos enumerados}:

\begin{description}
	\item[\code{enum format\_t}] Formato del archivo:
	
	\begin{description}
		\item[\code{SINGLE\_TRACK}] Una sola pista.
		\item[\code{MULTIPLE\_INDEPENDENT}] Varias pistas, simultáneas.
		\item[\code{MULTIPLE\_SIMULTANEOUS}] Varias pistas, independientes.
	\end{description}
	
	\item[\code{enum division\_t}] Unidad de medida de la división de tiempo:
	
	\begin{description}
		\item[TICKS\ PER\ BEAT] La división se especifica en \textit{ticks}/\quarternote.
		\item[FRAMES\_PER\_SECOND] La división se especifica en \textit{ticks/fotograma}.
	\end{description}
	
	\item[\code{enum midievent\_type\_t}] Tipo de evento \acrshort{MIDI}. Se enumeran en la tabla \ref{tab:midi_eventos}.
	\item[\code{enum metaevent\_type\_t}] Tipo de meta-evento. Se enumeran en la tabla \ref{tab:midi_metaeventos}.
	
	\item[\code{enum midimode\_t}] Modo tonal:
	
	\begin{description}
		\item[MAJOR] Modo mayor.
		\item[MINOR] Modo menor.
	\end{description}
\end{description}

Aparte del resto de transformaciones obvias, en pro de la velocidad de ejecución, hacemos los siguientes cambios:

\begin{enumerate}
	\item Anteponemos un \textbf{prefijo} a las funciones propias de cada estructura. El primer parámetro de todas ellas será un puntero a la misma.
	
	\item Eliminamos las funciones de consula que acceden llanamente a los parámetros, y a cambio sustituimos los parámetros simples por \textbf{uniones} con los nombres de las funciones.
	
	\item Ya que no podemos conocer a \textit{priori} el número de eventos que contendrá una pista, vamos a interpretar la composición propuesta por el diagrama \ref{fig:uml_midi} como una \textbf{lista enlazada} de eventos. Ya que la inserción y la lectura van a ser secuenciales, garantizamos una eficiencia algorítmica $O(1)$ en cada acceso.
\end{enumerate}

\subsection{Planificador}

El planificador es la parte más crítica del sistema: debe cronometrar y ejecutar los eventos del archivo que está abierto, y atender a las llamadas declaradas en la interfaz.

El procedimiento básico es sencillo: cada evento tiene una marca de tiempo respecto al evento anterior. El sistema debe "dormir" el tiempo indicado ejecutar el evento, y avanzar al siguiente, hasta la marca de fin de pista.

Solo vamos a atender cuatro tipos de evento:

\begin{enumerate}
	\item Evento NOTE\_ON, para activar una nota.
	\item Evento NOTE\_OFF, para desactivar una nota.
	\item Metaevento TEMPO, para establecer la velocidad.
	\item Metaevento END\_OF\_TRACK, para terminar.
\end{enumerate}

\subsubsection{Prototipo}

De la misma forma que hicimos con el descodificador de archivos \acrshort{MIDI}, vamos a escribir un prototipo sencillo en Python. Recibirá un objeto de la clase \code{MidiFile} e interpretará una de sus pistas, a fin de estudiar la salida y hacer ajustes si es necesario.

El algoritmo se estructurará según el siguiente diagrama:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo5/flujo_planificacion}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:flujo_planificacion} Diagrama de flujo del planificador (simple).}
\end{figure}

\smallskip

En este caso, implementamos la clase \code{Instrument} para abstraernos de la configuración del instrumento, que tendrá que definir mínimamente algunas funciones de la interfaz de salida:

\begin{description}[style=nextline]
	\item[\code{state}]
	Estado del instrumento. Almacena qué notas están activas y cuáles inactivas. En lugar de una lista de \textit{booleanos}, será un simple número entero que trataremos como un campo de \textit{bits}, correspondiendo el más significativo a la nota más aguda, y el \textit{bit} menos significativo a la tecla más grave.
	
	\item[\code{length}]
	Especifica el número de notas que admite nuestro instrumento. Será el ancho del campo de \textit{bits}.
	
	\item[\code{offset}]
	Indica la primera nota del instrumento como el desplazamiento respecto a la primera nota \acrshort{MIDI}.
	
	\item[\code{\_\_init\_\_(self, length, offset}]
	Constructor. Crea las estructuras de datos en \code{self} conociendo la longitud del teclado (\code{length}) y la primera nota (\code{offset}).
	
	\item[\code{note\_on(self, note)}]
	Activa la nota indicada (\code{note}), comprobando antes si está dentro del rango cubierto por el teclado.
	
	\item[\code{note\_off(self, note)}]
	Apaga la nota indicada (\code{note}) si ésta pertenece al teclado.
	
	\item[\code{play(self, midi, track)}]
	Método del planificador. Cronometra y ejecuta la pista indicada (\code{track}) del archivo de la clase \code{MidiFile}. Esta función implementa el algoritmo que queremos prototipar.
	
\end{description}

La salida es muy simple: muestra para cada evento el cambio producido y el estado actual:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo5/cap_pytest}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:cap_pytest} Captura de pantalla del prototipo.}
\end{figure}

\smallskip

El prototipo nos sirvió para extraer dos objeciones:

\begin{enumerate}
	\item El retraso ($\Delta$) del evento es inversamente proporcional al \textit{tempo} y a la división de tiempo, indicada en la cabecera del archivo. Así pues, como el \textit{tempo} se expresa invertido, la espera se calcula de la siguiente forma:
	
	\begin{center}
		$retraso \; (\mu s)  = \frac{\Delta \; (ticks) \; \times \; tempo \; (\mu s / \quarternote)}{division \; (ticks / \quarternote)}$
	\end{center}
	
	\item La semántica para desactivar una nota no solo se hace con un evento NOTE\_OFF, sino que algunas piezas lo especifican con un evento NOTE\_ON con velocidad 0. Esto resulta útil para ahorrar espacio de almacenamiento, repitiendo el mismo tipo de evento.
\end{enumerate}

Una vez corregidos estos detalles, el prototipo cumple su objetivo correctamente. 

\subsubsection{Implementación final}

El paso siguiente es implantar el algoritmo en C con los correspondientes añadidos. El más importante es que, en realidad, no debemos ejecutar una pista, sino tantas como tenga el archivo. Tenemos dos alternativas:

\begin{enumerate}
	\item A cada pista se le asigna una hebra de ejecución. Se inician todas a la vez y se esperan al final.
	\item Ampliamos el algoritmo para que ejecute todas las pistas de forma síncrona.
\end{enumerate}

Como hemos podido deducir del diseño, nos decantamos por la segunda opción, considerando que todas las hebras tendrían que sincronizarse con la interfaz de salida, haciendo más llamadas de las necesarias. Además, las llamadas al sistema para retrasar la ejecución, así como las dedicadas a sincronizar la exclusión mutua, desfasarían las pistas, provocando una interpretación musical incorrecta.

Ya que el procesador del \textit{Raspberry Pi} solo tiene un núcleo, no vamos a ganar tiempo dividiendo el proceso en hebras, si sabemos manejar correctamente las pistas. Para ello, diseñamos el algoritmo descrito en la sección \ref{subsec:planificador}, que requerirá una sola hebra, que llamaremos "hebra de reproducción".

El planificador define su interfaz de la siguiente manera:

\begin{description}[style=nextline]
	\item[enum player\_state\_t]
	
	Estado interno del reproductor.

	\begin{description}
		\item[\code{PAUSED}] En pausa.
		\item[\code{PLAYING}] Reproduciendo.
		\item[\code{STOPPED}] Detenido completamente.
		\item[\code{ENGINEER}] En modo Ingeniería. No se puede reproducir.
	\end{description}

	El orden de los tipos debe hacerse cuidadosamente para permitir al compilador generar un código óptimo \cite{vikman_switch}: Si las funciones utilizan la sentencia \code{switch} con etiquetas que comparten instrucciones (no todas acaban en \code{break}), es buena práctica que las etiquetas sigan el orden en que se ha declarado la enumeración.
	
	\item[\code{int player\_start(char **playlist, int n, int loop)}]
	Inicia la hebra de reproducción. Si ésta estaba en funcionamiento, primero la detiene. En primer lugar almacena la lista de rutas de archivo (\code{playlist}), el índice de la primera pieza a ejecutar (\code{n}) y la especificación de reproducir o no en bucle (\code{loop}).
	
	Ya que la terminación de la hebra anterior pudo ser natural o forzada, esta función es la encargada de eliminar la lista de reproducción precedente, si la hubiera. Una vez hecho esto, lanza la hebra de reproducción y devuelve el código de error (normalmente 0).
	
	\item[\code{int player\_wait()}]
	
	Bloquea a la hebra llamante hasta que la hebra de reproducción termine, y devuelve siempre \code{NULL}.
	
	\item[\code{int player\_pause()}]
	
	Comprueba que la hebra está funcionando y la pausa, cambiando el estado a \code{PAUSED}. A fin de evitar la espera activa de la hebra de reproducción, utilizaremos un semáforo de sincronización, que explicaremos más abajo.
	
	Devuelve 0 si ha pausado correctamente, o -1 si no estaba en ejecución.
	
	\item[\code{int player\_resume()}]
	
	Al contrario que la función anterior, comprueba que estaba en pausa, cambia el estado a \code{PLAYING} y señala el semáforo para despertar a la hebra de reproducción. Si estaba en reproducción, no hace nada. 
	
	Devuelve 0 si se ha reanudado la reproducción (o ya estaba funcionando), o -1 si estaba detenido.
	
	\item[\code{int player\_stop()}]
	
	Provoca la detención de la hebra de reproducción cambiando el estado a \code{STOPPED}, y espera a que la hebra termine efectivamente. Si estaba en pausa, primero despierta a la hebra para que termine por sí sola.
	
	Devuelve 0 si se ha detenido correctamente. Solo devuelve -1 si estaba en modo Ingeniería.
	
	\item[\code{player\_state\_t player\_state(char *file)}]
	
	Esta función devuelve el estado actual del reproductor. En caso de que estuviera en funcionamiento o pausado, copia en el parámetro \code{file} la ruta del archivo que está reproduciendo la hebra.
	
	\item[\code{int player\_engineer\_enter()}]
	
	Entra en el modo Ingeniería cambiando el estado a \code{ENGINEER}. Si la hebra estaba iniciada, previamente la detiene completamente. Si ya está en modo Ingeniería, no hace nada.
	
	Siempre devuelve 0.
	
	\item[\code{int player\_engineer\_exit()}]
	
	Sale del modo Ingeniería, si estaba dentro de él. El estado a la salida de \code{STOPPED}. Devuelve 0 si ha salido correctamente, o -1 si no estaba dentro.
\end{description}

Además, el módulo implementa los siguientes elementos de forma \textbf{estática}. Esto, en el ámbito del lenguaje C, significa que los símbolos no se exportan y, en consecuencia, solo las funciones dentro del módulo pueden llamarlas. Es el equivalente a los métodos privados en los lenguajes orientados a objetos. Son las siguientes:

\begin{description}[style=nextline]
	\item[\code{void* player\_run(void *arg)}]
	Punto de inicio de la hebra de reproducción. Consiste sencillamente en un bucle que recorre la lista de reproducción. En cada ciclo, abre el archivo correspondiente con ayuda del módulo \acrshort{MIDI} y lo ejecuta llamando a \code{playscore()}. Si la lectura falla, se ignora el archivo. En cualquier caso, después del uso, se destruye.
	
	Si se ha marcado la ejecución en bucle, al terminar de reproducir la lista, se vuelve al principio, indefinidamente. Si se diera el (improbable) caso de que todos los archivos de la lista fallen, la hebra termina.
	
	Devuelve siempre \code{NULL} como código de retorno del subproceso.
	
	\item[\code{int playscore(midifile\_t *file)}]
	
	Implementa el algoritmo de planificación para reproducir el archivo (\code{file}). Aplica el procedimiento descrito, al que añade una comprobación de estado en cada ciclo del bucle principal:
	
	\begin{description}
		\item[\code{PLAYING}] Continúa la ejecución normalmente.
		
		\item[\code{PAUSED}] Silencia la salida (manteniendo el estado) y pausa la reproducción. Como hemos adelantado, utiliza un semáforo para evitar la espera activa. El subproceso se bloquea hasta que otra hebra llame a \code{player\_pause()}, que es la que señala dicho semáforo.
		
		\item[\code{STOPPED}] Restablece la salida (borra el estado) y sale del bucle principal. 
	\end{description}
	
	Para un rendimiento óptimo, el bucle que ejecuta inmediatamente los eventos llama a \code{output\_noteon()} y \code{output\_noteoff()}, que cambian el estado del módulo de salida pero no la exportan efectivamente al instrumento. Cuando la racha termina, se sincroniza con la salida ---\code{output\_update()}--- y realiza la espera mediante una llamada a \code{nanosleep()}.

	El método de salida queda patente por el código de retorno:
	
	\begin{description}
		\item[0] Finalización natural.
		\item[1] Finalización forzada por una llamada a \code{player\_stop()}.
	\end{description}
	
\end{description}

\subsubsection{Concurrencia}

El planificador puede ser llamado por el servidor de \textit{socket}, el controlador del mando o el gestor del modo Ingeniería en cualquier momento, y en cualquier punto del reproductor. Esto puede llegar a generar \textbf{condiciones de carrera}, o incluso bloquear el sistema si dos módulos pretenden llevar a cabo acciones al mismo tiempo.

Además, debemos tener en cuenta posibles \textbf{usos ilegales} de la hebra de reproducción, como iniciarla, pausarla o detenerla varias veces consecutivas. Para evitar esto, como hemos descrito, las funciones públicas de control comprueban el estado antes de actuar.

A fin de no provocar una condición de carrera entre la hebra de reproducción y el resto, la primera nunca cambiará el estado, incluso si la partitura ha acabado. En su lugar activa una \textbf{variable "bandera"} volátil (no afectada por optimizaciones del compilador) para ser leída por las funciones de control. Si está marcada, cambiarán automáticamente el estado a \code{STOPPED}.

Para evitar inconsistencias entre funciones públicas, todas ellas utilizarán un \textbf{\acrshort{mutex}} que monitoriza las llamadas, haciendo que toda función deba esperar a que termine cualquier otra que estuviera funcionando.

Por último, la \textbf{espera activa} se evita con un semáforo que se comporta como un \acrshort{mutex}: La función \code{player\_pause()} en primer lugar decrementa el semáforo y luego pone el estado a \code{PAUSED} para que, en la próxima vuelta, el planificador lo detecte y se bloquee esperando al semáforo. Cuando cualquier función quiera despertar al planificador, lo hace al revés: primero pone el estado a \code{PLAYING} y después desbloquea el semáforo, así el planificador no cae dos veces por error en el código de espera. Una vez el reproductor consigue el semáforo, lo vuelve a incrementar. 

Hacemos esto así para que el valor ''por defecto'' sea 1, evitando problemas si se diera el caso de solicitar una pausa justo cuando el planificador ha salido del bucle y no va a esperar al semáforo. La alternativa era utilizar un \acrshort{mutex}, pero no tenemos garantía de que lo vaya a desbloquear la misma hebra (e.g. si pausamos desde la interfaz gráfica, en una hebra, y reanudamos desde el mando, en otra). Un \acrshort{mutex} caería en una \textbf{condición indefinida}, mientras que un semáforo responde correctamente.

\subsection{Salida GPIO}

Esta parte del programa supone el "puente" entre el planificador y la \acrshort{PCB}, transformará instrucciones de activación y desactivación de notas en señales lógicas que emitiremos por el \acrshort{GPIO}. 

Este módulo se diseñó de forma muy flexible para que se pudiera adaptar fácilmente a cualquier órgano, o incluso se pudiera dirigir a otra interfaz, como tal vez la salida estándar ---de hecho, en el simulador de reproducción (sección \ref{subsec:simulador_reproduccion}) redefiniremos la interfaz para que así sea---.

Todas las implementaciones deben tener en común el hecho de almacenar el estado de todas las notas del instrumento. Las llamadas a \code{output\_noteon()} y \code{output\_noteoff()} cambiarán ese estado, y \code{output\_update()} volcará efectivamente esta información en la salida.

\subsubsection{Prototipo}

Inicialmente hicimos una "prueba de concepto" en Python para entender el funcionamiento de los registros de desplazamiento. Como ya explicamos en la sección de análisis (\ref{subsec:conexion_mecanica}), cada registro está dedicado a un componente del órgano, pero todos funcionan igual.

La idea es conseguir ver en los \acrshort{led}s la interpretación de una pieza conocida y fácilmente reconocible. Hemos tomado como ejemplo el famoso \textit{Himno a la alegría} de Ludwig van Beethoven:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[clip=true,trim=20 580 20 30,width=\linewidth*3/4]{capitulo5/beethoven_1voz}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:beethoven_1voz} Fragmento del Himno a la Alegría de Beethoven.}
\end{figure}

\smallskip

Ya que no tenemos notas cromáticas, y disponemos de solo 7 \textit{bits} en la \acrshort{PCB}, vamos a establecer la siguiente equivalencia:

\smallskip

\begin{center}
	\begin{tabular}{|l|l|}
		\hline Do & \code{1000000} \\ 
		\hline Re & \code{0100000} \\ 
		\hline Mi & \code{0010000} \\ 
		\hline Fa & \code{0001000} \\
		\hline Sol & \code{0000100} \\
		\hline La & \code{0000010} \\
		\hline Si & \code{0000001} \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:equiv_notas_prot} Equivalencia de notas en el prototipo.}
\end{center}

\smallskip

Cualquier acorde no sería más que una combinación de bits. Todo lo que tenemos que hacer es volcar cada nota por separado, esperar el tiempo que hagamos corresponder a una negra (\quarternote) y silenciarlo todo (volcar solo ceros). El procedimiento es muy sencillo:

\begin{enumerate}
	\item Escribir el valor de una celda del vector en el puerto \acrshort{GPIO} correspondiente.
	\item Emitir un pulso en el puerto conectado a SRCLK para desplazar y almacenar.
	\item Repetir los pasos 1 y 2 con el resto de \textit{bits}.
	\item Emitir un pulso en el puerto conectado a RCLK para copiar del registro de desplazamiento al registro de almacenamiento.
\end{enumerate}

Para emitir un pulso en el registro, actuamos de la siguiente forma, de acuerdo al manual técnico de los registros:

\begin{enumerate}
	\item Escribir "1" en el puerto llamando a \code{output()}.
	\item Esperar 100 \textit{ns} con una llamada a \code{sleep()}.
	\item Escribir "0" en el puerto.
\end{enumerate}

\subsubsection{Implementación final}

Este módulo va a ser llamado síncronamente por el planificador, por lo que todas las funciones que implementemos deben de ser tan rápidas como sea posible. El primer detalle importante es escoger una \textbf{estructura de datos} eficiente para almacenar el estado.

En este caso, todos los registros tienen el mismo tamaño, y conocemos de antemano las dimensiones, con lo cual, tenemos dos opciones. Teniendo en cuenta que hay que indizar por (nota, pista), vamos a deducir el número de operaciones necesarias para la escritura (aleatoria) y la lectura (secuencial):

\begin{enumerate}
	\item Una variable entera \textbf{como campo de \textit{bits}}.
	\begin{itemize}
		\item Cada escritura requiere: indirección + multiplicación + suma + desplazamiento + conjunción + escritura. 
		\item Cada lectura requiere: desplazamiento.
	\end{itemize}
	
	\item Una \textbf{matriz de \textit{bytes}}.
	
	\begin{itemize}
		\item Cada escritura requiere: multiplicación + suma + escritura.
		\item Cada lectura requiere: suma + indirección.
	\end{itemize}
\end{enumerate}

La matriz de \textit{bytes} está mejor equilibrada, sobre todo teniendo en cuenta que se va a hacer más escrituras que lecturas. El campo de \textit{bits}, además, nos limita a 32 \textit{bits} en total, lo que nos obligaría a hacer modificaciones cuando extendamos los registros.

Crearemos la matriz de esta manera:

\smallskip

\begin{center}
	\begin{tabular}{|c|cccc|}
		\hline & \multicolumn{4}{c|}{N pistas} \\
		\hline \multirow{7}{*}{\rotatebox[]{90}{M notas}} & $s_{0,0}$ & $s_{0,1}$ & $s_{0,2}$ & $s_{0,3}$ \\
		& $s_{1,0}$ & $s_{1,1}$ & $s_{1,2}$ & $s_{1,3}$ \\
		& $s_{2,0}$ & $s_{2,1}$ & $s_{2,2}$ & $s_{2,3}$ \\
		& $s_{3,0}$ & $s_{3,1}$ & $s_{3,2}$ & $s_{3,3}$ \\
		& $s_{4,0}$ & $s_{4,1}$ & $s_{4,2}$ & $s_{4,3}$ \\
		& $s_{5,0}$ & $s_{5,1}$ & $s_{5,2}$ & $s_{5,3}$ \\
		& $s_{6,0}$ & $s_{6,1}$ & $s_{6,2}$ & $s_{6,3}$ \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:matriz_estatica} Configuración de las notas en el estado.}
\end{center}

\smallskip

El compilador, conociendo las dimensiones, convertirá la matriz estática en un \textit{array} de la siguiente forma:

\smallskip

\begin{center}
	\begin{tabular}{|c|}
		\hline $M\times N$ \textit{bytes} \\
		\hline $s_{0,0}$ $s_{0,1}$ $s_{0,2}$ $s_{0,3}$ $s_{1,0}$ $s_{1,1}$ ... $s_{6,2}$  $s_{6,3}$ \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:matriz_fisica} Disposición física de la matriz en memoria.}
\end{center}

\smallskip

Con esta estructura, el acceso aleatorio para escribir un valor en el estado se hará con la siguiente fórmula:

\begin{center}
	$s_{nota,pista} = v_{nota \times N + pista}$
\end{center}

Para volcar la información en los registros, seguiremos los mismos pasos que en el prototipo, pero en lugar de transmitir a un puerto \acrshort{GPIO}, transmitiremos a tantos como pistas tengamos, antes de enviar el pulso a SRCLK, que desplaza las notas de todos los registros a la vez.

Hemos organizado la matriz para que la lectura se hagan en el orden estricto en que están los datos en memoria, con lo cual, en lugar de acceder a la matriz directamente y obligar al compilador a hacer una multiplicación y una suma, utilizaremos \textbf{aritmética de punteros} para movernos por ella.

\subsubsection{Acceso directo al GPIO}

La siguiente cuestión es cómo acceder al \acrshort{GPIO}. Conocemos bien el sistema de archivos especial que nos brinda Linux, pero el hecho de actuar por medio de llamadas al sistema y acceso a ficheros para algo tan elemental podría resultar ineficiente.

Los puertos \acrshort{GPIO} son pines físicos del \acrshort{SOCA}, y se puede acceder a ellos mediante el periférico correspondiente mediante acceso a memoria. Estudiando el manual del BCM2835, obtenemos la siguiente información:

\smallskip

\begin{center}
	\begin{tabular}{|l|l|}
		\hline 0x20200000 & Dirección base \\
		\hline
		\hline Base + 0 & \multirow{6}{*}{Selección de función} \\
		\cline{1-1} Base + 4 & \\
		\cline{1-1} Base + 8 & \\
		\cline{1-1} Base + 12 & \\
		\cline{1-1} Base + 16 & \\
		\cline{1-1} Base + 20 & \\
		\hline Base + 24 & Reservado \\
		\hline Base + 28 & \multirow{2}{*}{Poner a "1"} \\
		\cline{1-1} Base + 32 & \\
		\hline Base + 36 & Reservado \\
		\hline Base + 40 & \multirow{2}{*}{Poner a "0"} \\
		\cline{1-1} Base + 44 & \\
		\hline \multicolumn{2}{|c|}{...} \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:gpio_struct} Direcciones físicas del GPIO.}
\end{center}

\smallskip

El controlador de \acrshort{GPIO} utiiza registros de 32-\textit{bit}. Para obtener un puntero a una dirección de memoria física, tan solo necesitamos hacer una llamada a \code{mmap(file = "dev/mem", offset = 0x20200000)} \cite{soii}. A partir de ahí, podemos acceder a cada registro con los desplazamientos adecuados. Hay un banco de registros para poner a "1", escribiendo un 1 lógico en el \textit{bit} correspondiente al número de puerto, y otro para poner a "0", escribiendo un 1 lógico en el \textit{bit} adecuado.

De esta forma logramos la mayor eficiencia, tanto por el acceso directo a memoria como la posibilidad de escribir en todas las pistas más el reloj en una sola operación de escritura.

\subsubsection{Mapeo y tolerancia}

Huelga decir que para logar una óptima reproducción, será necesario adaptar las partituras al órgano en cuestión, ya que cada ejemplar tendrá una rango de notas y un conjunto de registros distintos. Nuestra aplicación será lo más estándar posible a la hora de leer un archivo \acrshort{MIDI}, por ello, y para evitar errores por incompatibilidad, debemos contemplar que podemos recibir un archivo \acrshort{MIDI} cualquiera.

El número de pistas y el tamaño de cada una es conocido en tiempo de compilación, como ya sabemos. Las funciones \code{output\_noteon()} y \code{output\_noteoff()} reciben el código de nota y el índice de pista, que se escribirá en el estado. Un detalle simple, pero importante, será \textbf{descartar} cualquier nota fuera del rango, y cualquier pista no declarada.

Por otro lado, no es estrictamente necesario que el orden de las pistas en el archivo (pentagramas) coincida con el orden de los registros en la \acrshort{PCB}. Para modelar esto, tendremos un \textit{array} con los números de puerto \acrshort{GPIO} asociados a cada pista del archivo \acrshort{MIDI}:

La asignación por defecto, para el órgano de prueba, será la siguiente:

\smallskip

\begin{center}
	\begin{tabular}{|l|c|c|c|c|}
		\hline \textbf{Pista} & 1 & 2 & 3 & 4 \\
		\hline \textbf{Puerto GPIO} & 02 & 03 & 17 & 04 \\
		\hline \textbf{Canal PCB} & S1 & S2 & S4 & S3 \\
		\hline \textbf{Componente} & Teclado 1 & Teclado 2 & Registros & Pedalier \\
		\hline 
	\end{tabular}
	\smallskip
	\captionof{table}{\label{tab:asig_canales} Asignación de pistas al GPIO.}
\end{center}

\smallskip

\subsection{Servidor socket}

Esta parte del programa es la vía de acceso al servicio, se dedica a atender las peticiones de otras aplicaciones, como la interfaz web, según el protocolo de comunicación diseñado. Para ello utiliza un \textit{socket} de Unix \cite{wiki_socket}, similar a los \textit{sockets} de Internet, pero dedicado a la comunicación inter-proceso dentro de la misma máquina, a través de memoria compartida.

El \textbf{código de inicialización}, en la función \code{socket\_init(uid, gid)}, hace lo siguiente:

\begin{enumerate}
	\item Crea la estructura de archivos de programación.
	\item Asigna un archivo \textit{socket} en el sistema de archivos. Por defecto será \code{/run/organd.sock}.
	\item Prepara el zócalo para escucha (modo servidor).
	\item Establece como propietario el \acrshort{UID} y el \acrshort{GID} que recibe como parámetros, correspondientes a un usuario especial.
	\item Solicita ignorar la señal \code{SIGPIPE}, que colgaría el programa si un cliente se desconecta repentinamente.
\end{enumerate}

Por otro lado, el procedimiento \code{socket\_loop()} inicia el \textbf{bucle de escucha}: se bloquea hasta recibir una nueva petición y, a partir de ahí, actúa siguiendo el protocolo establecido en la sección \ref{sec:protocolo}, transmitiendo las órdenes al planificador.

Recordemos que el planificador recibe una lista de nombres de archivo, como una matriz de caracteres, de cuya destrucción se ocupa él mismo. La función \code{socket\_play()} pues, clasifica la lista de archivos recibidas en la cadena a una lista de cadenas, antes de pasarla al planificador (\code{player\_start()}).

\subsection{Servidor UART}

El módulo de servicio del \acrshort{UART} tiene una estructura similar al del \textit{socket}, solo que atiende a las peticiones del mando a distancia que llegan por el \textbf{puerto en serie}. Por un lado el protocolo de comunicación es más sencillo, por otro, no conocemos la información de las listas asociadas a un botón, por lo que hay que hacer consultas a la \textbf{base de datos}.

En primer lugar, \code{uart\_init()} abre la comunicación con el puerto en serie y establece los parámetros de configuración adecuados al receptor del mando (9600 \textit{baudios}) y bloqueo hasta recibir 10 caracteres, que es la longitud de la cadena que esperamos recibir.

Para iniciar el \textbf{bucle de recepción} implementamos \code{uart\_loop()}, que simplemente crea una hebra y la inicia en \code{uart\_run()}. Como adelantamos en la fase de análisis (sección \ref{analisis_mando}), el descodificador envía en primer lugar el \textbf{número de serie} del mando, que comparamos con el número de serie registrado en tiempo de compilación. 

A continuación leemos el \textbf{código del botón}, codificado como ya describimos, y seguimos adelante según este esquema para un mando de cuatro botones:

\begin{description}
	\item[Botón 1] Inicia la lista de reproducción asignada al botón 1.
	\item[Botón 2] Reproduce la lista asignada al botón 2.
	\item[Botón 3] Pausa la reproducción, o la reanuda.
	\item[Botón 4] Detiene la ejecución completamente.
\end{description}

Para reproducir una lista, escribimos el código en una función auxiliar, \code{uart\_playlist()}, que se comunica con la \textbf{base de datos} en busca de una lista de reproducción asignada, y los nombres de archivo correspondientes, para generar un \textit{array} de rutas de fichero y llamar a \code{player\_start()}.

Por otro lado, la función de \textbf{pausa/reanudar} llama a la función \code{uart\_pause()}, encargada de consultar el estado del planificador y actuar en consecuencia: si estaba funcionando llama a \code{player\_pause()}, y si estaba pausado ejecuta \code{player\_resume()}; en otro caso no realiza ninguna acción.

Por último, el botón para \textbf{detener} simplemente hace llamar a \code{player\_stop()}, cuyo funcionamiento es inocuo si el reproductor ya estaba parado.

\subsection{Comunicación con la base de datos}

El módulo receptor del mando necesita conocer la asignación de botones a listas, y las rutas de archivo de las partituras pertenecientes a las listas. Esta información está almacenada en una base de datos, y el acceso se hace a través de un módulo aparte, con objeto de presentar una interfaz independiente del \acrshort{SGBD} que utilicemos.

Como explicaremos más adelante, utilizaremos \textbf{MySQL}, de forma que nuestro módulo utilizará la biblioteca cliente de MySQL para C. Así, la implementación de las funciones de inicio y cierre, \code{db\_init()} y \code{db\_destroy()}, respectivamente, simplemente abren la comunicación con MySQL mediante \code{mysql\_real\_connect()} y la terminan con \code{mysql\_close()}.

Para conectarse a la base de datos hay que conocer el \textbf{nombre de usuario} y la \textbf{contraseña} asignados a dicha base, que conocemos de antemano y están guardados en tiempo de compilación.

La última función diseñada, \code{db\_query()}, es la encargada de realizar consultar la lista de archivos en la base de datos, conocido el número de botón pulsado. La información recibida es devuelta como un puntero a una matriz de caracteres, a tratar por el módulo llamador.

\subsection{Modo Ingeniería}

El diseño ha contemplado un control de la mecánica del sistema, a través del \acrshort{LCD} y el codificador rotatorio, que consiste en un menú que permite entrar en modo Ingeniería para activar y desactivar las notas a placer, de una en una.

Como especificamos en la sección \ref{subsec:ingenieria}, la gestión de esta interfaz está diseñada como una máquina de estados. La función \code{periph\_init()} se encarga de preparar los puertos \acrshort{GPIO} asignados al codificador, e inicializa el \acrshort{LCD}. Por seguridad, activaremos la polarización de los puertos \acrshort{GPIO} de acuerdo a la utilizada por el codificador:

\begin{itemize}
	\item \textit{Pull-up} para los canales A y B (giro).
	\item \textit{Pull-down} para el pulsador.
\end{itemize}

Por último, esta función crea una hebra independiente para gestionar la máquina de estados.

\subsubsection{Control de entrada}

El codificador rotatorio producirá los eventos de entrada. De acuerdo con el análisis de este dispositivo (sección \ref{subsec:rotary}), entre dos puntos de equilibrio cambia el canal A, y entonces, dependiendo del valor de los canales A y B ---si coinciden o difieren--- interpretaremos un giro a la izquierda y otro a la derecha.

De esta forma, tenemos que esperar dos eventos:

\begin{enumerate}
	\item Cambio en el canal A.
	\item Subida en el pulsador.
\end{enumerate}
	
A fin de evitar la \textbf{espera activa}, se crearán dos hebras que se bloquearán hasta recibir la señal correspondiente, cuando llamarán a dos funciones asignadas como \textit{callbacks}:

\begin{description}[style=nextline]
	\item[rot\_change()] Ha cambiado el canal A. Lee A y B, los compara y activa la bandera correspondiente.
	\item[rot\_push()] Se ha pulsado el botón. Activa la bandera de pulsación.
\end{description}

Ambas funciones utilizan un \textit{array} de banderas (\textit{flags}) para indicar qué evento está pendiente de atender, y señalan un \textbf{semáforo} para el control de la máquina de estados.

\subsubsection{Máquina de estados}

La función principal de la hebra de control es \code{periph\_run()}, que implementa un bucle para atender los eventos y definir el estado siguiente. La implementación de esta función sigue la especificación del diagrama de la figura \ref{fig:engineer}.

Cuando entra en modo Ingeniería, llama a la función del planificador \code{player\_engineer\_enter()}, que lo aísla de la salida del \acrshort{GPIO}, dejándolo libre para actuar sobre él con las llamadas a bajo nivel \code{output\_noteon()} y \code{output\_noteoff()}.

Al final del bucle, el subproceso se bloquea esperando que el usuario actúe y el \textit{callback} correspondiente señale el semáforo.

\subsubsection{Control de salida}

La salida de este módulo se hace sobre el \acrshort{LCD}, que realimentará las acciones del usuario en modo Ingniería. Sin embargo, mientras no se use este modo, se mostrará el estado del planificador y, en su caso, la ruta del archivo que se está reproduciendo.

Para ello, cuando el bucle de la máquina de estados ha calculado el estado siguiente, se refresca la pantalla en función del nuevo estado, ya sea:

\begin{enumerate}
	\item Navegar por el menú.
	\item Mostrar el estado del reproductor.
	\item En modo Ingeniería, indicar la pista actual y la nota que está activa.
\end{enumerate}

Para mostrar el estado del reproductor, hay que tener en cuenta que la información va a cambiar aunque el usuario no interactúe con los mandos. Por ello, la espera del semáforo será \textbf{temporizada}: si tras un tiempo determinado el usuario no toca el control, la hebra se despierta sola y refresca la pantalla.

\subsection{Inicio del demonio}

Ahora vamos a crear el punto de inicio de nuestro servicio, para que se inicie durante el arranque del sistema operativo del \textit{Raspberry Pi}. Lo que este módulo hará será muy sencillo: iniciar todos los módulos y llamar a los bucles de escucha que incorporan en hebras diferentes.

\subsubsection{Características}

Un demonio ---en nomenclatura de la familia Unix--- es un programa que se ejecuta en segundo plano, es iniciado por el \textit{boostrap} del sistema operativo y no interactúa directamente con el usuario. Está diseñado para dar servicio a otras aplicaciones. Ni siquiera utiliza la entrada y salida estándar, en su lugar usa el registro del sistema.

Al mismo tiempo, y paradójicamente, debe terminar lo antes posible para permitir que continúe el arranque del sistema. Para iniciar correctamente el demonio, la función principal del programa recibirá el ID del usuario y del grupo con que actuará el demonio, y hará lo siguiente: \cite{shahmir_daemon}

\begin{enumerate}
	\item Crea una copia de sí mismo mediante una bifurcación, llamando a \code{fork()}. Como ya sabemos, esta función devuelve el ID del hijo al proceso padre y 0 al proceso hijo. En este punto, el padre termina.
	
	\item Crea una nueva sesión mediante \code{setsid()}, convirtiendo al proceso hijo en líder de su grupo de procesos.
	
	\item Cambia la carpeta de trabajo por la raíz del sistema, llamando a \code{chdir(''/'')}.
	
	\item Cierra mediante \code{close()} los descriptores de archivo de la entrada y salida estándar: \textit{stdin}, \textit{stdout} y \textit{stderr}.
	
	\item Abre el \textit{log} del sistema con \code{openlog()}.
	
	\item Inicia el módulo del \textit{socket}.
	
	\item Arranca el módulo del mando a distancia.
	
	\item Inicia el módulo del modo Ingeniería.
	
	\item Rebaja sus permisos a los del \acrshort{UID} y el \acrshort{GID} recibidos.
	
	\item Inicia el bucle de escucha del servidor del puerto en serie (en otra hebra).
	
	\item Llama al bucle de servicio del \textit{socket}.
	
\end{enumerate}

Otra acción importante es \textbf{programar el cierre} controlado mediante una sencilla función que detenga la reproducción y llame a las funciones de limpieza ---las que terminan en \code{\_destroy()}---:

\begin{enumerate}
	\item Planificar dicha llamada cuando se termine el programa, haciendo uso de \code{atexit}.
	\item Programar una salida normal ---\code{exit(0)}--- cuando se reciba la señal SIGTERM, que es la que envía por defecto \code{kill} y la que corresponde a pulsar Ctrl+C.
\end{enumerate}

\subsubsection{Script de arranque}

Conforme a la base estándar de Linux ---\acrshort{LSB}, \textit{\acrlong{LSB}}---, el arranque del sistema buscará un \textit{script} para iniciar el demonio en una ubicación dependiente del nivel de ejecución, y lo llamará con el argumento \code{''start''}. \cite{debian_lsbinit}

Con objeto de arrancar los distintos servicios en el orden correcto para preservar dependencias, debemos escribir una cabecera en el código, que utilizará la orden \code{insserv} para registrar el servicio. En ella especificaremos la siguiente información:

\begin{enumerate}
	\item Requiere el servicio \code{syslog}, para el \textit{log} del sistema.
	\item Se iniciará en los niveles de ejecución 2, 3, 4, 5 (multiusuario). \cite{wiki_runlevel}
	\item Se parará en los niveles 0, 1 y 6 (monousuario, apagar y reiniciar).
\end{enumerate}

De acuerdo al estándar, el \textit{script} atenderá a las siguientes órdenes:

\begin{description}
	\item[start] Arranca el demonio. Busca el proceso con \code{ps -e | grep}, si no lo encuentra, consulta el \acrshort{UID} y \acrshort{GID} del usuario dedicado, y llama al servicio pasando ambos argumentos.
	
	\item[stop] Busca el proceso y, si lo encuentra, lo detiene con \code{kill} y espera a que haya finalizado.
	
	\item[restart] Detiene el servicio y lo vuelve a iniciar.
	
	\item[force-reload] Esta orden sirve para recargar la información. Nuestro programa no tiene nada que hacer al respecto.
	
	\item[status] Informa de si el proceso está iniciado o no. Si está funcionando muestra el estado del planificador (reproduciendo, detenido, pausado o en modo Ingeniería).
\end{description}

\subsubsection{Permisos de usuario}

El demonio es llamado por el proceso \code{init} (que está empezando a ser reemplazado por \code{systemd}), por supuesto con permisos de superusuario (\textit{root}). Mantener al proceso con tales privilegios es inseguro. El servicio debe cambiar de usuario y de grupo con \code{setuid()} y \code{setgid()} cuando haya terminado de iniciar los dispositivos que requieren permisos especiales, especialmente el \acrshort{GPIO}, que mapea un puntero en memoria física.

Para manejar los permisos adecuadamente, crearemos un usuario de sistema, de uso exclusivo para el demonio. Su \acrshort{UID} y su \acrshort{GID} serán los que reciba el ejecutable al iniciar el servicio.

\subsection{Seguridad}
\subsubsection{Permisos de usuario}
\subsubsection{Conexiones simultáneas}
\subsubsection{Compatibilidad con MIDI estándar}

\subsection{Pre-instalación}

Para facilitar la compilación y la puesta en marcha del demonio, vamos a construir un \textit{script} que prepare el sistema para el funcionamiento del servicio, instalando los paquetes necesario y haciendo las configuraciones pertinentes.

El \textit{script} es muy sencillo y hace lo siguiente:

\begin{enumerate}
	\item Instala la biblioteca cliente de \textbf{MySQL} para C, incluyendo las cabeceras.
	\item Crea un usuario y grupo de sistema, llamados \textbf{''organ''}, que poseerán el proceso del demonio y el \textit{socket}.
	\item Descarga la biblitoeca \textbf{WiringPi} del repositorio de su desarrollador, y la compila.
	\item Crea las carpetas \textbf{bin} y \textbf{obj}, para alojar los archivos compilados.
\end{enumerate}

\subsection{Compilación e instalación}

La compilación y la instalación del servicio está gestionada \textbf{\textit{Makefile}}, que trabaja sobre la siguiente estructura de directorios:

\begin{description}
	\item[bin] Archivos ejecutables finales.
	\item[include] Ficheros de cabecera de C.
	\item[obj] Código objeto, ensamblado pero no vinculado.
	\item[scripts] Código de pre-instalación y arranque del demonio.
	\item[src] Ficheros de código fuente en C.
\end{description}

El \textit{Makefile} contiene las siguientes reglas:

\begin{description}
	\item[all] Por defecto. Compila todos los ejecutables.
	\item[install] Instala los archivos compilados en el sistema operativo.
	\item[uninstall] Deshace la instalación.
	\item[preinstall] Ejecuta los pasos de pre-instalación.
	\item[clean] Elimina todos los archivos compilados.
	\item[objclean] Limpia los ficheros de código objeto.
\end{description}

Las carpetas utilizadas como destino de instalación son las siguientes:

\begin{description}
	\item[/usr/local/bin] Programas auxiliares.
	\item[/usr/local/sbin] Ejecutable del demonio (binarios de superusuario).
	\item[/etc/init.d] \textit{Script} de inicio del servicio.
\end{description}

\section{Interfaz web}

Es ahora el momento de abordar la construcción del \textit{back-end} del sistema. Como ya sabemos, será un servidor \acrshort{HTTP}. Hemos tenido en cuenta las siguientes \textbf{alternativas} como lenguajes de programación para el servidor:

\begin{itemize}
	\item \textbf{C/C++ con \acrshort{CGI}}. Sería la solución más rápida en tiempo de ejecución, por ser lenguajes compilados. A cambio, la programación sería mucho más lenta, porque trabajamos a más bajo nivel.
	
	\item \textbf{PHP 5}. Es quizás la opción más popular, es un lenguaje interpretado y diseñado para entornos \textit{web}.
	
	\item \textbf{Python 3 con la biblioteca Django}. También es un lenguaje interpretado, la biblioteca Django tiene una estructura más complicada, diseñada para sitios complejos.
\end{itemize}

Estudiadas las tres opciones, consideramos que la mejor es \textbf{PHP}, por equilibrar rendimiento y comodidad de programación. En el capítulo posterior probaremos el tiempo de ejecución de las páginas, que es más que aceptable.

El servidor generará una página \textbf{\acrshort{HTML} 5}, la última versión del estándar. La estética se escribirá en \textbf{\acrshort{CSS} 3}. En el lado del cliente, siempre es necesario actuar sobre una página generada, donde utilizaremos \textbf{JavaScript} para acceder a ella a través de \acrshort{DOM} ---\textit{\acrlong{DOM}}---.

Además, debemos almacenar las cadenas constantes en archivos, dependiendo del idioma del usuario; para esto usaremos archivos \textbf{\acrshort{XML}}. Otra tecnología que nos resultará útil es \textbf{\acrshort{AJAX}} ---\textit{\acrlong{AJAX}}---, para que JavaScript haga consultas al servidor sin recargar la página completa.

En resumen usaremos las siguientes tecnologías:

\begin{enumerate}
	\item PHP 5.4, como lenguaje de programación.
	\item \acrshort{HTML} 5, como lenguaje de marcado.
	\item \acrshort{CSS} 3, para las hojas de estilos.
	\item \acrshort{XML}, para almacenar información estática.
	\item JavaScript, \acrshort{AJAX} y \acrshort{DOM}, para interactuar dinámicamente con la página.
\end{enumerate}

\subsection{Estructura principal}

Vamos a organizar los archivos de una forma limpia y fácil de acceder. Para ello, en la carpeta raíz tendremos los archivos PHP correspondientes a las vistas, y otro para el control. Cada \textbf{vista} se implementará en un archivo diferente, para facilitar la consulta. Ya que el \textbf{controlador} recibirá datos privados, se implementará en un solo archivo.

El resto de ficheros se clasificarán de las siguientes carpetas:

\begin{description}
	\item[ajax] Páginas PHP de uso exclusivo para \acrshort{AJAX}.
	\item[images] Imágenes para la página.
	\item[lib] Bibliotecas PHP, para el modelo y para la vista.
	\item[scripts] Código JavaScript a cargar por las páginas.
	\item[styles] Hojas de estilos en cascada, en \acrshort{CSS}.
	\item[translations] Ficheros de traducción, en \acrshort{XML}.
\end{description}

\subsubsection{Plantillas}

A medida que construimos la maqueta en \acrshort{HTML} y \acrshort{CSS}, fuimos conscientes de qué trozos de código se repetían, totalmente o con un ligero cambio, lo que nos ayudó a crear una biblioteca de plantillas, que podríamos denominar ''rutinas de vista''.

En ella hemos escrito las siguientes funciones:

\begin{description}[style=nextline]
	\item[\code{html\_open(id, refresh)}]
	Genera la cabecera \acrshort{HTML}. Establece el \code{id} del documento, y opcionalmente, una \acrshort{URL} de redirección (\code{refresh}).
	
	\item[\code{html\_close()}]
	De manera contraria, escribe el final del documento \acrshort{HTML}.
	
	\item[\code{html\_header(full)}]
	Modela la barra de cabecera. Si se indica \code{full} se hace completa, incluyendo los controles de energía (apagar y reiniciar). Si se pasa el valor \code{false}, entonces solo se muestra el cambio de idioma.
	
	\item[\code{html\_navigation (selected)}]
	Escribe la barra de navegación, marcando como seleccionado aquel elemento de la lista cuyo ID coincida con el valor de \code{selected}.
	
	\item[\code{html\_footer}]
	Muestra el pie de página de la vista.
	
	\item[\code{html\_error (type)}]
	Genera una página completa con un mensaje de error, y cuyo texto depende del parámetro \code{type}. A continuación termina el programa.
	
	\item[\code{html\_redirect (target)}]
	Crea una página sin contenido, dedicada a redireccionar a otra, cuya \acrshort{URL} se indica en \code{target}.
	
	\item[\code{html\_script (src)}]
	Escribe el texto \acrshort{HTML} necesario para incluir el archivo JavaScript especificado en \code{src}.
\end{description}

\subsubsection{Controlador}

Este archivo implementará todas las funciones de control del sistema, como iremos describiendo más adelante. Tan solo especificar que la ejecución de este módulo se lleva a cabo con una mezcla de parámetros \textit{GET} y \textit{POST}:

\begin{description}
	\item[GET] Solo se envía el nombre de la acción a ejecutar, como \code{control.php?action=login}.
	\item[POST] Transmite el resto de la información, cuyos parámetros dependen de la acción.
\end{description}

De esta forma se evita que el explorador o eventualmente un motor de búsqueda cacheen una instancia. Si la orden se ejecuta correctamente, se devuelve una página en blanco con \textbf{redirección} a la vista adecuada (se pierde la dirección y no se relanza la orden si actualizamos la página). En caso de \textbf{error}, se muestra pero se mantiene la dirección en el explorador para poder volver a intentarlo.

\subsubsection{Sesión}

Este módulo implementa el modelo de la sesión para permitir que todos los parámetros a almacenar sean accedidos por el resto de archivos a través de funciones, evitando errores lógicos. La interfaz está descrita en la sección \ref{subsec:session}, del capítulo de diseño.

La sesión de usuario es una \textit{cookie} gestionada por el intérprete de PHP, que se incluye en la cabecera \acrshort{HTTP} al principio del programa, llamando a \code{session\_start()}. A partir de ahí, tenemos acceso a la variable global \code{\_SESSION}, un \textit{array} del que utilizaremos tres claves:

\begin{description}
	\item[auth] Tiene el valor 1 si el usuario se ha autentificado. Se escribe con \code{set\_auth()} y \code{unset\_auth()} y se consulta con \code{get\_auth()}.
	
	\item[last] Hace referencia a la consulta de la última vista ejecutada, por si el controlador debe volver a ella. Se escribe con \code{set\_page()} y se lee con \code{last\_page()}.
	
	\item[lang] Almacena el código de lenguaje seleccionado por el usuario o, en su defecto, el idioma preestablecido. Se escribe con \code{set\_language()} y se consulta con \code{get\_language()}.
\end{description}

\subsubsection{Hoja de estilos}

El modelo estándar de implementación de páginas \acrshort{HTML} separa contenido y forma en distintos archivos, así, todo el estilo de la interfaz se escribe en hojas de estilos en cascada.

Nuestra interfaz será homogénea, de manera que todos los estilos se definirán en un solo archivo \acrshort{CSS}. El objetivo es obtener un resultado lo más cercano posible al diseño, donde tenemos un ejemplo en la figura \ref{fig:maqueta}.

Sin adentrarnos en el código, existen tres zonas bien distinguidas en el fichero:

\begin{enumerate}
	\item Reglas \textbf{generales}, como el margen, la tipografía o el color de la fuente.
	\item Opciones para los \textbf{elementos}, dependiendo de su etiqueta \acrshort{HTML}.
	\item Reglas \textbf{específicas}, sobre todo a determinadas páginas. Esta es la razón por la que cada vista tiene un ID diferente.
\end{enumerate}

Como podemos ver en las siguientes figuras, hemos conseguido una estética en \acrshort{CSS} prácticamente similar a la diseñada con Photoshop.

\subsection{Traductor}

El traductor es el módulo en el que delegamos todo el texto que aparecerá en las vistas y será dependiente del idioma que escoja el usuario. Como especificamos en la sección \ref{subsec:idiomas} del capítulo de diseño, cada archivo de traducción implementará un elemento \code{<translation>} como raíz, dedicado a un solo lenguaje.

Un ejemplo para un ''Hola Mundo'' en dos idiomas sería el siguiente:

\begin{verbatim}
	<translation code="es" language="Español">
	    <string name="hello">¡Hola Mundo!</string>
	</translation>

	<translation code="it" language="Italiano">
	    <string name="hello>Ciao Mondo!</string>
	</translation>
\end{verbatim}

El programa en PHP busca todos los archivos existentes en la carpeta de traducciones con \code{glob()} y los interpreta con ayuda de la función \code{simplexml\_load\_file()}. A continuación los guarda en una lista global, denominada \code{translators}, a acceder por todas las funciones que la requieran.

El hecho de leer todos los archivos de lenguaje se explica en el \textbf{menú desplegable} que se mostrará en la barra de cabecera, y presenta todos los idiomas disponibles. Cada opción está vinculada al \textbf{controlador}, que lanza la orden \code{language} con el código de idioma como parámetro.

\subsection{Control de energía}

Una de las funciones de la interfaz sería controlar el reinicio y el apagado del \textit{Raspberry Pi}. Esta acción solo se puede llevar a cabo con la orden correspondiente de Linux, y con permiso de superusuario.

La implementación es tan sencilla como mostrar en la cabecera un \textbf{menú desplegable} con ambas opciones, cada una llama a controlador con una acción diferente:

\begin{description}
	\item[shutdown] Hace ejecutar la función \code{shutdown()}, que solo llama a \code{sudo shutdown now}.

	\item[reboot] Ejecuta la función \code{reboot()}, que llama a \code{sudo shutdown -r now}.
\end{description}

Ambas llamadas devuelven un código de retorno (0 en caso de éxito o 1 en caso de error). El controlador filtra dicho código para redirigir a la portada, o bien mostrar un mensaje de error.

Recordar que el usuario del servidor Apache (www-data) no posee por defecto privilegios para realizar cambios que afecten al equipo. Por ello modificaremos el sistema para concederle tales permisos, como explicaremos más adelante, en la sección \ref{subsec:web_seguridad}.

\subsection{Portada}

La portada constituye la primera página que se muestra al acceder al sistema. La \textbf{vista} incluye un fondo de pantalla dinámico, que cambia a intervalos de tiempo regulares.

Para esto hemos implementado una función en JavaScript llamada \code{toggle()}, que guarda una lista de imágenes y altera el estilo del fondo de la página.

Otro elemento importante es un \textbf{formulario} que permite introducir la contraseña de usuario y nos lleva al \textbf{controlador}, con la acción \code{login}.

\subsubsection{Autentificación}

El \textbf{controlador} recibe la contraseña por el método \textit{POST}, para ocultarla de la vista de la dirección y evitar que sea cacheada. Todo lo que hará será llamar a una \textbf{aplicación auxiliar} de la que hablaremos más tarde, en la sección \ref{subsec:aux_login}. A esta aplicación le pasamos el nombre de usuario (predefinido por nosotros) y la contraseña introducida como parámetros de llamada, y nos devuelve 0 (correcto) o 1 (error).

Si se aprueba el acceso, llamamos a \code{set\_auth()} para registrarlo en la sesión y redirigimos al \textbf{reproductor}. En caso contrario, volvemos a la pantalla con parámetro \code{error=1}, de forma que se mostrará un pequeño mensaje de error:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo5/cap_login_error}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:cap_login_error} Formulario de entrada con mensaje de error.}
\end{figure} 

\smallskip

\subsection{Navegación}

Para movernos cómodamente entre las páginas de la interfaz, hemos diseñado una barra lateral de navegación. Consiste en una lista de vínculos, adornados con iconos mediante estilos. 

La función de la plantilla que la crea, \code{html\_navigation()}, utiliza el ID de la página para indicar la clase \code{selected} al vínculo correspondiente. La hoja de estilos se encarga de que dicho elemento se dibuje de otro color para remarcar la página actual.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo5/cap_navigation}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:cap_navigation} Barra lateral de navegación.}
\end{figure} 

\smallskip

\subsection{Conexión a la base de datos}

De manera análoga a como hicimos en el demonio para comunicarnos con la base de datos independientemente del motor utilizado, en la interfaz dedicaremos un módulo a conectarnos a la base de datos MySQL.

La estructura de datos que más utilizaremos serán \textbf{mapas asociativos} (\textit{arrays} con claves), ya que son la estructura subyacente en los objetos de PHP y, por consiguiente, más eficientes.

Nuestro módulo establecerá una conexión con la base de datos, creando un objeto \code{mysqli}, la nueva versión del cliente MySQL para PHP. Las credenciales y el nombre de esquema quedan predefinidos mediante constantes. En caso de \textbf{error}, se mostrará un mensaje con \code{html\_error()}, y no podremos continuar hasta que solucionemos el problema.

Todas las funciones definidas están descritas en la sección \ref{subsec:web_database} de diseño. El \textbf{procedimiento habitual} para ejecutar una sentencia es el siguiente:

\begin{enumerate}
	\item Creamos una sentencia preparada con \code{prepare()}, a partir del código SQL correspondiente, marcando con una interrogación ('?') los valores que irán parametrizados.
	\item Utilizamos el método \code{bind\_param()} para enlazar cada parámetro con su argumento correspondiente, que recibiremos en la llamada a la función.
	\item Ejecutamos la sentencia con el método \code{execute()}.
	\item Recibimos la información requerida con \code{get\_result()}.
	\item Clasificamos los datos según sea necesario, y los devolvemos.
\end{enumerate}

\subsection{Conexión al demonio}

Si el demonio implantaba un servidor de \textit{socket}, nosotros vamos a escribir un \textbf{cliente} que se conecte a él.

\subsubsection{Prototipo}
\subsubsection{Implementación}

\subsection{Reproductor}
\subsubsection{Vista}
\subsubsection{Controlador}

\subsection{Gestión de listas y piezas}
\subsubsection{Vista}
\subsubsection{Controlador}

\subsection{Asignación del mando}
\subsubsection{Vista}
\subsubsection{Controlador}

\subsection{Seguridad}
\label{subsec:web_seguridad}
\subsubsection{Inyección de código SQL}
\subsubsection{Inyección de código shell}
\subsubsection{Permisos de superusuario}


\section{Base de datos}

\section{Aplicaciones auxiliares}
\subsection{Información de archivo MIDI}
\subsection{Simulador de reproducción}
\label{subsec:simulador_reproduccion}
\subsection{Terminal del reproductor}
\subsection{Comprobación de contraseña}
\label{subsec:aux_login}
\subsection{Instalador del servidor}