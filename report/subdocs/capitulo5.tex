\chapter{Implementación del sistema.}
\label{cap: capitulo_5}


En la fase de implementación es donde se sintetiza todo el análisis realizado anteriormente,
y se procede a formalizar el producto resultante. Como solución \textit{hardware} se plantea el
diseño del circuito en placa impresa (\acrshort{PCB}), llevándose al proceso de
fabricación y soldado de componentes. Por otro lado, en el aspecto \textit{software} se explicará el
método de programación seguido para la rutina de control, y se perfilará el firmware final.

\section{Implementación \textit{Hardware}}
\label{sec:ImpHard}
Tal y como se introdujo en el la sección \ref{sec:ImpFirm}, el software ALTIUM Designer
versión 14.1 ha sido empleado para el diseño del circuito, tanto para el apartado esquemático
como para el diseño de la placa PCB. Este segundo punto consiste en posicionar los elementos
del circuito de manera que queden interconectados entre ellos siguiendo el patrón designado
en el esquemático. Esta interconexión consiste en pistas grabadas sobre una placa de cobre,
que será las encargadas de transportar corriente y permitir al circuito su funcionamiento.

\subsection{Diseño y fabricación de \acrshort{PCB}}
\label{sec:Diseño}

Partiendo del circuito esquemático de los diseños se genera el \textit{layout} que constituye, junto
con los componentes, el circuito electrónico del dispositivo. Para ello, ALTIUM Designer
ofrece multitud de funcionalidades que facilitan el trabajo y permiten alcanzar magníficos
resultados. Demasiadas para ser expuestas en estas líneas, aunque podemos resaltar la comodidad
para gestionar distintos proyectos y librerías, la creación de componentes en todos
sus niveles, y asistencia continua durante el diseño del layout que posibilitan un diseño de
calidad óptimo y minimizan los posibles errores
Realizado el conexionado lógico entre los distintos terminales (definido en el esquemático),
se procede a plantear la disposición física de los elementos, incluidas las pistas que interconectan
dichos terminales. Para realizar el \textit{layout}, no solo se necesita conocer la información
de los elementos a nivel funcional y eléctrico, sino también las especificaciones mecánicas del
encapsulado y del sustrato que soporta los componentes.

La PCB la fabricaremos mediante el uso de una LPKF ProMat S62. Con la cual obtendremos una pracisión de 0.01 mils.

\hfill
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.6]{capitulo5/maquina}
\par\end{centering}
\caption{\label{fig:maquina} LPKF ProMat S62.}
\end{figure}
\smallskip


\subsection{Consideraciones previas}
Las siguientes consideraciones se tuvieron muy en cuenta ya que tienen un gran impacto en el resultado final de la \acrshort{PCB}. Ignorarlas haría que el funcionamiento no fuera el deseado.

\begin{itemize}
	\item \textbf{Anchura de las pistas y distancia entre las mismas:}Para el dimensionamiento de las pistas existen un gran número de parámetros que influyen en su tamaño final. En este proyecto se han tenido en cuenta la corriente que circula por la pista, el incremento de temperatura que experimentará ésta durante su funcionamiento, la distancia a la que está la pista más próxima, las propiedades del material sobre el que se imprime la \acrshort{PCB}, sus dimensiones y por último se añadió un margen de seguridad. Con el fin de obtener unos cálculos más precisos, se hizo uso del documento de Excel creado por Jack Olson \cite{Jack}, un diseñador de \acrshort{PCB}s que lleva mas de veinte años trabajando en este campo y que ha obtenido un certificado avanzado del IPC en Diseño de Interconexiones(CID).
	
El dimensionamiento final fue 20 mils para las pistas de conexión entre los pins del Arduino UNO y los distintos devices, 50 mils para las pistas que van a 5V y entre 250 y 322 mils para las pistas de potencia.
	
	\item \textbf{Espaciado de componentes.}Debido a que la soldadura se realiza de forma manual,
con un soldador de estaño, es necesario tener acceso a patillas y pads de contacto,
junto con sus superficies de soldado. Cada montaje sugiere un espaciado concreto, pero
distancias de unos pocos milímetros suelen ser válidas.

	\item \textbf{Dimensiones de las huellas.}Con el componente colocado sobre la huella, es deseable
que se pueda tener acceso a dicha huella, facilitando así las labores de soldado. Para
estas dimensiones suele ser suficiente con unas décimas de milímetro. Un dimensionado
de huellas pensado para soldado con pasta en horno de \textit{reflow} o similar, puede complicar
notablemente la tarea.

	\item \textbf{Alineamiento de doble cara y dimensiones de vías y taladros.}Las placas
de doble cara llevan asociado el uso de vías y pads para componentes de agujero
pasante, y constituyen orificios que conectan el \textit{layout} de ambas capas. Por tanto,
cualquier elemento del diseño de una capa que constituya un orificio deberá estar
perfectamente alineado con la otra capa. Puesto que el alineamiento se realiza de forma
manual, las dimensiones vías y orificios están limitadas por dos cuestiones: la destreza
visual (incluso con el posible uso de microscopio o aparatos de aumento ópticos) y de
alineamiento manual, y la exactitud y diámetro de las herramientas de taladrado. Con
las herramientas disponibles, se pueden conseguir orificios de hasta 0.8 mm con un
alineamiento adecuado.

	\item \textbf{Metalización de vías y localización.}Otra de las restricciones de las vías (además
de sus dimensiones mínimas) se trata de la carencia de herramientas adecuadas para
la metalización. Mediante este proceso, estas vías son simplemente taladros, que
no ofrecen conexión eléctrica alguna entre ambas capas. Esa conexión se logra introduciendo
un pequeño cable, o elemento conductor, que se suelda por ambas caras, y
posteriormente se elimina el excedente. En cualquier caso, siempre supone un relieve
en el orificio de dicha vía, frente a las vías planas de fabricación industrial. Esto implica
que las vías no pueden localizarse debajo de componentes \acrshort{SMD} cuyo encapsulado
no disponga de espacio con la superficie de la placa. Así mismo, los componentes de
agujero pasante solo estarán conectados eléctricamente con la cara opuesta al componente,
ya que habitualmente no se podrá soldar la patilla por ambas caras del pad.
Este detalle ha de tenerse muy en cuenta para evitar errores indeseados en el diseño.
\end{itemize}

\subsection{Modelo en 2D y 3D}
En esta sección se mostrará el resultado obtenido, tanto en 2D como en 3D. En la figura \ref{fig:noNet_net} podemos observar en la imagen de la izquierda la disposición de los distintos componentes que contendrá nuestra \acrshort{PCB} sin incluir las \textit{nets} que conectarán unos con otros. La \textit{rats net} nos indicará qué va conectado con que. En la imagen de la derecha,  se muestra el resultado final del ruteo.




El último paso es colocar los planos de masa. Para ello hacemos uso de la herramienta \textit{Polygon pour} de Altium. Hay que tener presente que hay que colocar un plano de masa tanto en la capa \textit{Bottom} como en la \textit{Top}.


Una vez terminado la colocación de componentes, ruteo y planos de masa, podemos ver como quedará nuestro producto en 3D. A continuación, se presentarán imágenes del modelo en 3D desde distintas perspectivas. 

Una vez terminados los modelos 2D y 3D procederemos a la fabricación. Como ya dijimos en la sección \ref{sec:Diseño}, usaremos una LPKF ProMat S62. Podemos dividir el proceso en dos fases:

\begin{enumerate}
\item Preparación archivos GERBER y NCdrills: Mediante el programa CircuitCAM preparamos el archivo de extensión .LMD que será el que contenga toda la información de por dónde debe trazar la fresadora las pistas y realizar los agujeros.
\item Procesado del archivo .LMD: Mediante el software BoardMaster calibramos el plotter PROTOMAT S62, preparamos la placa FR4, e importamos el archivo .LMD, desde el cual se fabricará finalmente la PCB.
\end{enumerate}

\subsection{Resultado final}
Una vez impresa la PCB y colocados todos los componentes, el resultado es el siguiente:

IMAGENES DE LA PCB FINAL POR LA PARTE DE ARRIBA Y ABAJO

Ya solo falta ver donde la colocaremos en el horno. De las distintas posibilidades que había se opta por colocarla en un lateral. Para ello se perfora el horno para que, una vez colocada, solo se vean el \glsname{LCD}, el rotary, el pulsador y los leds. El resultado se puede ver en la figura \ref{fig:corte}.


\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.08]{capitulo5/corte}
\par\end{centering}
\caption{\label{fig:corte} NO SE QUÉ PONER.}
\end{figure}
\smallskip

Finalmente, colocamos la \acrshort{PCB}. 

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.1]{capitulo5/fin}
\par\end{centering}
\caption{\label{fig:fin} NO SE QUÉ PONER.}
\end{figure}
\smallskip

\section{Implementacion \textit{Software}}

En los siguientes apartados se detallarán las distintas funciones de las que consta el código fuente.

\subsection{Configuración del \glsname{LCD}} 
La configuración del \glsname{LCD} es bastante simple. Lo único que necesitamos son las librerias \glsname{SPI}.h y LiquidCrystal.h. 
La librería \glsname{SPI}.h la usamos para la conexión serie entre Arduino UNO y nuestro \glsname{LCD}. Siendo el Arduino UNO el maestro y el \glsname{LCD} el esclavo. Con esta librería controlamos las líneas \glsname{MISO}, \glsname{MOSI} y \glsname{SCK}. Estas líneas nos permitirán mandar datos entre el Arduino UNO y el \glsname{LCD}.
La librería LiquidCrystal.h nos permite controlar el \glsname{LCD} desde el Arduino UNO. Incluye una gran variedad de funciones entre las que destacaremos:

\begin{itemize}
\item \textbf{begin(columnas,filas).} Inicia la pantalla del \glsname{LCD} y especifica las dimensiones.
\item \textbf{setCursor(columna,fila).} Fija el cursor en una posición determinada.
\item \textbf{clear().} Limpia el \glsname{LCD} y sitúa el cursor en la esquina superior izquierda.
\end{itemize}

\subsection{Rotary encoder}
NI IDEA DE LO QUE HACE LA RUTINA


\subsection{Lectura de temperatura}
Para la lectura de la temperatura haremos uso de la función analogRead. AnalogRead lee la tensión que tenemos en un pin y la divide en 1024 niveles, del modo que 0 Voltios equivaldría al nivel, o step, 0, y 5 Voltios a 1023, por lo que podemos decir que: 

\begin{equation}
V=\left(\frac{analogRead(PT100)*5}{1024}\right) V
\end{equation}

Sabiendo el valor de la corriente que circula por la PT100, podemos calcular el valor de la resistencia mediante:

\begin{equation}
R=\left(\frac{V}{I_{PT100}}\right) \Omega 
\end{equation}

Una vez sabemos el valor de la resistencia podemos calcular el valor de la temperatura. Partiendo que el valor de la resistencia es,

\begin{equation}
R(t)=R(0)[1+A*t+B*t^{2}] \Omega 
\end{equation}

podemos despejar t en función de los parámetros A, B, R(t) y R(0). Donde:
\newline
\newline
 R_0 = 100 \Omega
\newline
A=3,908 * 10^{-3}
\newline
B=-5,775 * 10^{-7}

Despejando queda: 

\begin{equation}
T=\left(\frac{-100*A*\sqrt{100^2*A^2-4*100*B*(100-R(t))}}{2*100*B}\right) ^{\circ}C
\end{equation}


Una vez implementado esto, tras varias pruebas, observamos que obtenemos mucho ruido en nuestros resultados, tal y como muestra la figura \ref{fig:prueba1}.

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.55]{capitulo5/prueba1}
\par\end{centering}
\caption{\label{fig:prueba1} Datos obtenidos en la primera lectura de temperatura.}
\end{figure}
\smallskip

Ya que estas medidas no son fiables, aplico un filtro de media para suavizar el ruido. Pero no es suficiente, los datos siguen teniendo mucho ruido.  

Es por esto que implemento un filtro \glsname{FIR} paso bajo para intentar eliminar el ruido. Para el cálculo del orden y coeficientes del filtro \glsname{FIR} hago uso de la aplicación de Matlab \textit{Filter Design & Analysis Tool}. 
Los datos que necesitamos para este filtro son el tiempo de muestreo y entre que frecuencias queremos nuestra banda de paso bajo. Por defecto, el orden que nos da Matlab es el optimo para el filtro. Pero es demasiado grande y al tener que realizar tantas operaciones el Arduino, se queda sin memoria. Es por esto que seleccionamos un orden acorde a nuestra memoria. La frecuencia de muestreo la obtenemos calculando cada cuanto tiempo tomamos una muestra de temperatura. Para ello nos ayudamos del osciloscopio para tener una exactitud mayor. Obtenemos que cada 9ms(337micro segundos) tenemos una muestra, por lo que la frecuencia de muestreo será de 111Hz.

AQUI SIGO CON LOS DATOS OBTENIDOS DE MATLAB, ESPERAR A TENER EL HORNO MONTADO Y VER HASTA CUANTO PUEDO LLEGAR DE ORDEN DEL FILTRO.

Una vez implementado el filtro \glsname{FIR} podemos observar como mejora nuestras lecturas de temperatura y no tenemos tanto ruido como al principio.






\subsection{Lectura del pulsador}
La lectura del pulsador se hace comprobando el estado del boton ha cambiado. Para evitar el efecto rebote introducimos un tiempo de debounce para que no nos lea dos pulsaciones al pulsar una sola vez el pulsador. 

\section{Implementación del algoritmo \glsname{PID}}
En este apartado se explicará los pasos seguidos para el ajuste del algoritmo \glsname{PID}. Empezaremos estudiando cada uno de los distintos métodos de ajuste de parámetros \glsname{PID}.
Los métodos que estudiaremos en los siguientes apartados son:

\begin{itemize}
\item Sintonía Zieger-Nichols. \cite{Ibrahim}
\item Método del relé. \cite{wilson}
\item Ajuste manual del sistema.\cite{Skogestad}
\end{itemize}

\subsection{Sintonía Zieger-Nichols}
Busca valores para los parámetros \glsname{PID} de la planta basado en la respuesta del sistema en
lazo abierto o cerrado. Para poder emplear el método ZN en lazo abierto es necesario que la
respuesta del sistema ante un escalón de potencia sea de tipo S, figura \ref{fig:ZN1}:

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.7]{capitulo5/ZN1}
\par\end{centering}
\caption{\label{fig:ZN1} Lazo abierto con respuesta tipo S\cite{Ibrahim}.}
\end{figure}
\smallskip

Los parámetros \glsname{PID} se obtienen empleando la siguiente tabla: 

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.7]{capitulo5/ZN2}
\par\end{centering}
\caption{\label{fig:ZN2} Parámetros \glsname{PID} para Zieger-Nichols\cite{Ibrahim}.}
\end{figure}
\smallskip

Para la sintonización en lazo cerrado, se realiza el siguiente procedimiento manual:

\begin{enumerate}
\item Se activa únicamente el control proporcional, y se ajusta la respuesta a un determinado \textit{set point}.
\item Se modifica el valor de $K_{p}$ hasta conseguir ver una oscilación estable en la salida. Este
valor de ganancia será la ganancia crítica, $K_{u}$.
\item Se obtiene el período crítico $K_{p}$ de la señal oscilatoria, figura \ref{fig:ZN3}:

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.7]{capitulo5/ZN3}
\par\end{centering}
\caption{\label{fig:ZN3} Lazo cerrado con ganancia crítica\cite{Ibrahim}.}
\end{figure}
\smallskip

\item Finalmente se ajustan los parámetros con la siguiente relación:

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.7]{capitulo5/ZN4}
\par\end{centering}
\caption{\label{fig:ZN4} Parámetros \glsname{PID} para ZN en lazo cerrado\cite{Ibrahim}.}
\end{figure}
\smallskip

\end{enumerate}

\subsection{Método del relé}
Es una variante del método ZN de lazo cerrado, y consiste en la incorporación de un
relé en la salida del bloque \glsname{PID} que realmente actúa como si fuese un bloque ON/OFF. Se
obtiene el período crítico $P_{u}$ y con él la ganancia crítica $K_{u}=\frac{4d}{\pi a}$, figura \ref{fig:rele1}.

\smallskip
\begin{figure}[H]%here
\noindent \begin{centering}
\includegraphics[scale=0.7]{capitulo5/rele1}
\par\end{centering}
\caption{\label{fig:rele1} Sintonización con método del relé\cite{Wilson}.}
\end{figure}
\smallskip


\subsection{Ajuste manual}
Este método se emplea cuando los diferentes algoritmos de sintonización no terminan de
ajustarse correctamente, o para mejorar ciertas características como el sobredisparo, tiempo
de respuesta, etc... Requiere un conocimiento avanzado del comportamiento de la planta. El
procedimiento es el siguiente:


\begin{enumerate}
\item Se activa únicamente el control proporcional para un determinado set point. Se intenta
que el sobredisparo no sea demasiado alto y que la señal quede cercana a la consigna
seleccionada.
\item Se añade el control integral y se modifica su valor observando el cambio en las siguientes
características:

\begin{itemize}
\item Sobredisparo.
\item Error en set point.
\item Tiempo de establecimiento.
\item Grado de oscilación.
\item Estabilidad en la potencia de salida.
\end{itemize}

Cada modificación realizada en el parámetro integral $T_{I}$ se hace aumentando o disminuyendo
el valor al doble o mitad del valor anterior respectivamente.

\item Si persisten oscilaciones de alta amplitud en el bloque PI se reajustan los parámetros
siguiendo la siguiente relación: $K'_{P}T'_{I}=fK_{P}T_{I}$ , con $f=0.1\frac{P_{0}}{T_{Io}}$, siendo P_{0} y T_{Io} el período de oscilación y la constante de tiempo integral anterior, respectivamente.
\item Para controlar oscilaciones de baja amplitud y mejorar la respuesta del sistema, se
agrega el bloque derivativo y se modifica el valor de $T_{D}$ observando los cambios para
las mismas características vistas en el bloque integral. Este parámetro es muy sensible
y puede conducir fácilmente a una inestabilidad en la potencia de salida, por lo que se
debe incluir únicamente en los casos en los que se aprecie una mejora significativa.
\end{enumerate}

\subsection{Sintonización \glsname{PID} del horno}
Empezamos empleando el método de sintonía de Zieger-Nichols fijando un \textit{setpoint} de $T=50^{\circ}C$. Tras varias pruebas obtenemos que para $a=K_{P}=3$ la respuesta queda cercana al punto de consigna.


Podemos observar oscilaciones que presentan un periodo crítico de $P_{u}= 3800s$. Si aplicamos las reglas de sintonización de Zieger-Nichols para lazo cerrado:

$$K_{u}=0.45K_{P}=1.35$$
$$T_{I}=\frac{P_{u}}{1.2}=3166$$
Por lo que finalmente los parámetros de sintonización son:

$$a=K_{u}=1.35$$
$$b=\frac{K_{u}T}{T_{I}}=0.0042$$




$$K_{u}=0.6K_{P}=1.5$$
$$T_{I}=\frac{P_{u}}{2}=1900$$
$$T_{I}=\frac{P_{u}}{8}=475$$

Por lo que finalmente los parámetros de sintonización son:

$$a=K_{u}=1.5$$
$$b=\frac{K_{u}T}{T_{I}}=0.007$$
$$c=\frac{K_{u}T_{D}}{T}=712.5$$

