\chapter{Diseño del sistema.}
\label{cap: capitulo_4}

En este capítulo vamos a detallar cómo hemos concebido la solución a los requisitos \textit{software}, teniendo en cuenta los correspondientes al \textit{hardware} y a partir de los elementos que hemos detallado en el capítulo anterior.

\section{Planteamiento}

Como idea más abstracta, el \textit{software} que tenemos que diseñar consiste en un reproductor de archivos \textit{MIDI}, que recibe el fichero y lo envía a la \textit{PCB} a través del \textit{GPIO}. Por supuesto, la reproducción estará controlada por el usuario:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/idea}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:idea} Planteamiento inicial.}
\end{figure} 

\smallskip

Luego, dividiremos el sistema en cuatro grandes bloques. Respecto al de control, se requiere varias formas de acceder al sistema:

\begin{enumerate}
	\item Un \textit{software} controlador principal, que cubra todos los casos de uso, y sea fácil de instalar y utilizar, con preferencia de que sea multiplataforma.
	
	\item Un mando a distancia, que altere la reproducción.
	
	\item Un control reducido empotrado en la \textit{PCB}.
\end{enumerate}

Atendiendo a los requisitos del primer controlador y a las prestaciones del \textit{Raspberry Pi}, y con objeto de eliminar la necesidad de instalar y mantener aplicaciones en otro sistema, decidimos enfocar la solución como una interfaz \textit{web} con un servidor alojado en el \textit{Raspberry Pi}. De esta forma podemos llegar fácilmente a cualquier sistema operativo de escritorio, incluso es fácilmente adaptable a dispositivos móviles.

Sin embargo, el reproductor no puede funcionar dentro de un servidor \textit{web}, ya que éstos atienden peticiones sin estado, y se cierran automáticamente después de devolver la información. Por ello, vamos a diseñar el reproductor como un \textit{demonio} de \textit{Linux}, junto con sus módulos auxiliares.

En último lugar, necesitamos almacenar información de los archivos \textit{MIDI}, listas de reproducción y asignaciones del mando en memoria persistente. Una base de datos nos permitiría guardar toda esa información de manera estructurada y coherente, además de ser fácilmente accesible por todos los componentes del sistema.

\section{Demonio del reproductor}

Un demonio ---\textit{daemon}--- es un proceso que se ejecuta en segundo plano en la fase de arranque del sistema operativo, y no interactúa directamente con el usuario, sino que se comunica con otros procesos a través de herramientas proporcionadas por el sistema operativo.

Este programa será el núcleo de nuestro sistema, y ofrecerá las siguientes vías para comunicarse:

\begin{enumerate}
	\item Un \textit{socket} local de \textit{Linux}. Será usado principalmente por la interfaz \textit{web}, pero es una forma flexible y eficiente para que lo hagan más aplicaciones.
	
	\item El puerto en serie (\textit{UART}) del \textit{Raspberry Pi}, para recibir órdenes del mando.
	
	\item Los pines del \textit{GPIO} correspondientes al codificador rotatorio y el \textit{LCD}, para la interfaz reducida.
\end{enumerate}

Así, el esquema de uso de los distintos componentes queda así:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon} Diagrama de uso entre los componentes del reproductor.}
\end{figure} 

\smallskip

\subsection{Descodificador de MIDI}

Como hemos detallado más arriba, el formato \textit{MIDI} expone los eventos de control en orden temporal, clasificados por pistas, habitualmente simultáneas. Debemos proporcionar una estructura de datos que permita mantener cada archivo a reproducir en memoria y facilitar el acceso individual a cada pista.

Concebimos la estructura de datos como un conjunto de listas enlazadas de eventos. El tamaño de los eventos normales es constante, sin embargo, los meta-eventos extienden la semántica con una cadena de datos.

\subsubsection{Estructura \textit{midifile\_t}}

Define un archivo \textit{MIDI}. Sus campos son:

\begin{description}
	\item[format : \textit{enum}] Formato del archivo. Puede tener los siguientes valores enumerados:
	
	\begin{description}
		\item[SINGLE\_TRACK] Una sola pista.
		\item[MULTIPLE\_SIMULTANEOUS] Varias pistas, simultáneas.
		\item[MULTIPLE\_INDEPENDENT] Varias pistas, independientes.
	\end{description}
	
	\item[ntracks : \textit{word}] Número de pistas.
	
	\item[division : \textit{enum}] Unidad de medida de la división de tiempo:
	
	\begin{description}
		\item[TICKS\ PER\ BEAT] La división se especifica en \textit{ticks}/\quarternote.
		\item[FRAMES\_PER\_SECOND] La división se especifica en \textit{ticks/fotograma}.
	\end{description}
	
	\item[tracks : \textit{array(midievent\_t)}] Conjunto de listas de eventos; cada lista corresponde a una pista.

\end{description}

\subsubsection{Estructura midievent\_t}

Define un evento MIDI.

\begin{description}
	\item[delta : \textit{dword}] Separación temporal respecto al evento anterior.
	\item[type : \textit{enum}] Tipo de evento. Se enumeran en el capítulo anterior.
	\item[param1 : \textit{byte}] Valor del primer parámetro, dependiendo del tipo de evento.
	\item[param2 : \textit{byte}] Valor del segundo parámetro, dependiendo del tipo de evento.
	\item[metaevent : \textit{metaevent\_t}] Información del metaevento, si procede.
	\item[next : \textit{midievent\_t}] Evento siguiente, si procede.
\end{description}

\subsubsection{Estructura \textit{metaevent\_t}}

Define un meta-evento.

\begin{description}
	\item[type : \textit{emum}] Tipo de metaevento. Se enumeran en el capítulo anterior.
	\item[length : \textit{dword}] Longitud de la cadena de datos, en \textit{bytes}.
	\item[data : \textit{string}] Cadena de datos correspondientes al meta-evento.
\end{description}

\subsubsection{Funciones}

\begin{description}[style=nextline]
	\item[midifile\_init (score, path) : \textit{int}] 
	Lee un archivo MIDI e inicializa la estructura recibida. 
	
	\begin{description}
		\item[score : \textit{midifile\_t}] Archivo \textit{MIDI} sin inicializar.
		\item[path : \textit{string}] Ruta del fichero a leer.
	\end{description}
	
	Devuelve 0 en caso de éxito, o -1 en caso de error.
	
	\item[midifile\_destroy (file)] 
	Elimina una estructura y libera su memoria.
	
	\begin{description}
		\item[file : \textit{midifile\_t}] Archivo \textit{MIDI}.
	\end{description}
	
	\item[midifile\_duration (file) : \textit{dword}] 
	Obtener la duración de una pieza.
	
	\begin{description}
		\item[file : \textit{midifile\_t}] Archivo \textit{MIDI}.
	\end{description}
	
	Devuelve la duración de la pieza, en \textit{segundos}.
	
	\item[metaevent\_tempo (event) : \textit{dword}] 
	Obtener el \textit{tempo} de la pieza.
	
	\begin{description}
		\item[event : \textit{metaevent\_t}] Meta-vento.
	\end{description}
	
	Devuelve el \textit{tempo} de la pieza en \textit{$\mu s$/\quarternote}.
	
\end{description}

\subsubsection{Diagrama de uso}

El módulo \textit{MIDI} solo se usa directamente a través del planificador. Éste se encarga de gestionar las partituras, y ordenar su eliminación cuando sea necesario.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_midi}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_midi} Diagrama de uso del módulo MIDI.}
\end{figure} 

\smallskip

\subsection{Control por socket}

Un \textit{socket} un mecanismo de comunicación inter-proceso ---\textit{IPC (inter-process communication)} que proporciona \textit{Linux} y enviar y recibir datagramas en modo \textit{duplex}, bien dentro de la misma máquina (\textit{socket} local) o en una red (\textit{socket} de Internet).

Vamos a crear un \textit{socket} local, accesible desde el sistema de archivos de \textit{Linux}, que escuche peticiones de los clientes que se conecten, utilizando una interfaz basada en lenguaje natural, que explicaremos a continuación.

Las funciones diseñadas son las siguientes:

\begin{description}[style=nextline]
	\item[socket\_init (uid, gid) : \textit{dword}]
	Inicializar el \textit{socket} con el ID de usuario y grupo indicados.
	
	\begin{description}
		\item[uid : \textit{dword}] ID de usuario en Linux.
		\item[gid : \textit{dword}] ID de grupo en Linux.
	\end{description}
	
	Devuelve 0 en caso de éxito y -1 en caso de error.
	
	\item[socket\_destroy ()]
	Cierra el \textit{socket}.
	
	\item[socket\_loop ()]
	Despliega una hebra con un bucle de escucha y atiende las peticiones.
	
\end{description}

\subsubsection{Diagrama de uso}

El módulo correspondiente al \textit{socket} solamente interacciona internamente con el planificador, al que transmite adecuadamente las órdenes recibidas.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_socket}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_socket} Diagrama de uso del servidor \textit{socket}.}
\end{figure} 

\smallskip

\subsubsection{Lenguaje de la interfaz}

El \textit{socket} reconocerá y ejecutará una serie de órdenes, emitiendo siempre una respuesta:

\begin{description}
	\item[PLAY <archivo> [ <archivo>*]] Reproducir una lista de archivos MIDI, indicando las rutas completa, separadas por espacios. Respuesta:
	
	\begin{description}
		\item[OK] en caso de éxito.
		\item[ERROR] en caso de error o estar en modo Ingeniería.
	\end{description}
	
	\item[PLAYLOOP <archivo> [ <archivo>*]] Reproducir en bucle una lista de archivos MIDI, indicando las rutas completa, separadas por espacios. Respuesta:
	
	\begin{description}
		\item[OK] en caso de éxito.
		\item[ERROR] en caso de error o estar en modo Ingeniería.
	\end{description}
	
	\item[PAUSE] Pausar la reproducción. Silencia las notas pero manteniendo el estado. Respuesta:
	
	\begin{description}
		\item[OK] en caso de éxito.
		\item[ERROR] en caso de error, como estar detenido, o en modo Ingeniería.
	\end{description}
	
	\item[RESUME] Reanuda la reproducción en el punto en que se pausó. Respuesta:
	
	\begin{description}
		\item[OK] en caso de éxito.
		\item[ERROR] en caso de error, como no estar pausado, o en modo Ingeniería.
	\end{description}
	
	\item[STOP] Detiene completamente la reproducción y libera la lista de reproducción. Respuesta:
	
	\begin{description}
		\item[OK] en caso de éxito.
		\item[ERROR] en caso de error o estar en modo Ingeniería.
	\end{description}
	
	\item[STATUS] Consulta el estado del reproductor. Respuesta:
	
	\begin{description}
		\item[PLAYING <archivo>] Reproduciendo el archivo cuya ruta absoluta se especifica.
		\item[PAUSED <archivo>] Pausado en un punto del archivo cuya ruta se indica.
		\item[STOPPED] Detenido. Es el estado inicial.
		\item[ENGINEER] En modo Ingeniería. No se puede reproducir nada hasta desbloquearse.
	\end{description}
	
\end{description}

\subsection{Control del mando}

Como hemos indicado en el capítulo anterior, el receptor del mando a distancia está conectado al \textit{Raspberry Pi} a través de los pines correspondientes al dispositivo \textit{UART} ---\textit{Universal Asynchronus Receiver-Transmiter}---, que controla los puertos serie.

Este módulo tiene una topología análoga al control por \textit{socket}, tan solo cambia el origen y la forma de entrada de los datos. Establecerá una comunicación con el puerto serie e iniciará un bucle de escucha. La sintaxis del mensaje, como ya sabemos, es:

\begin{center}
	<Nº serie (7 \textit{bytes})> <Botón (1 \textit{byte})> <CRLF>
\end{center}

De esta forma, el servicio tan solo debe verificar el nº de serie y ejecutar la orden correspondiente.

Además de reconocer la pulsación del mando, es necesario consultar en la base de datos, que detallaremos más adelante, la lista que corresponde al botón pulsado y los archivos contenidos, que serán transmitidos al planificador.

Las funciones correspondientes a este módulo son las siguientes:

\begin{description}[style=nextline]
	\item[uart\_init () : \textit{dword}]
	Establece comunicación con el puerto serie.
	
	Devuelve 0 en caso de éxito y -1 en caso de error.
	
	\item[uart\_destroy ()]
	Cierra la comunicación.
	
	\item[uart\_loop ()]
	Despliega una hebra con un bucle de escucha y ejecuta las órdenes.
	
\end{description}

\subsubsection{Diagrama de uso}

Este bloque interacciona con el planificador en unos términos similares al \textit{socket}, y utiliza la interfaz de la base de datos.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_uart}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_uart} Diagrama de uso del receptor de radio.}
\end{figure} 

\smallskip

\subsection{Comunicación con la base de datos}

La información relativa a la lista de reproducción asignada a un botón, así como la lista de partituras correspondientes, residirán en una base de datos, que definiremos próximamente. Así, enmarcaremos un nuevo módulo dedicado a consultar la información requerida, ofreciendo una interfaz independiente del sistema de gestión de bases de datos que utilicemos, y de la propia base de datos, mediante las siguientes funciones:

\begin{description}[style=nextline]
	\item[db\_init () : \textit{dword}]
	Inicia la comunicación con el gestor de bases de datos. Devuelve 0 en caso de éxito y -1 en caso de error.
	
	\item[db\_destroy ()]
	Cierra la comunicación.
	
	\item[db\_query (scores, idshortcut) : \textit{dword}]
	Realiza la consulta mencionada, asignando a \textit{scores} la lista de piezas a reproducir.
	
	\begin{description}
		\item[scores : \textit{array(string)}] Lista de rutas a las piezas.
		\item[idshortcut : \textit{dword}] ID del botón que se ha pulsado en el mando.
	\end{description}
	
	Devuelve el número de piezas asignadas (pudiendo ser 0), o -1 en caso de error.
	
\end{description}

\subsubsection{Diagrama de uso}

La interfaz de la base de datos es utilizada exclusivamente por el servidor del receptor de radio, sin perjuicio de que en un futuro podamos extender su funcionalidad, por lo que la hemos separado lógicamente del módulo \textit{UART}. El diagrama de uso es el siguiente:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_bd}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_bd} Diagrama de uso de la interfaz de base de datos.}
\end{figure} 

\smallskip

\subsection{Planificador}

El planificador es la pieza principal del reproductor. Recibe las órdenes de los controladores y la lista de partituras a ejecutar. Una a una las lee con ayuda del módulo \textit{MIDI} y planifica los eventos de todas las pistas para lanzarlos a la salida en el momento necesario.

Al igual que otros módulos, utiliza una hebra para reproducir los archivos, pero en este caso es una hebra dinámica, que podrá ser iniciada, pausada y detenida por el resto de procesos, por lo que hay que tener en cuenta los problemas de concurrencia para garantizar la consistencia del sistema.

La interfaz que el planificador ofrece es la que sigue:

\begin{description}[style=nextline]
	\item[player\_start (playlist, n, loop) : \textit{dword}]
	Inicia la reproducción de una lista de archivos. Si ya estaba reproduciendo una lista, primero detiene la reproducción y elimina la lista antigua.
	
	\begin{description}
		\item[playlist : \textit{array(string)}] Lista de rutas absolutas a los archivos que queremos reproducir.
		\item[n : \textit{dword}] Número de piezas que se han transmitido en el parámetro anterior.
		\item[loop : \textit{bool}] Utilizar (1) o no (0) reproducción en bucle.
	\end{description}
	
	Devuelve 0 en caso de éxito o -1 en caso de error.
	
	\item[player\_pause () : \textit{dword}]
	Pausa la reproducción, si estaba activa. Devuelve 0 en caso de éxito o -1 en caso de error.
	
	\item[player\_stop () : \textit{dword}]
	Detiene completamente la reproducción, si estaba activa o pausada. Si estaba parado, no hace nada. Devuelve 0 en caso de éxito o -1 en caso de error.
	
	\item[player\_wait () : \textit{dword}]
	Espera a que el reproductor se detenga. Solo tiene sentido llamarla en caso de no estar reproduciendo en bucle. Devuelve 0 en caso de éxito o -1 en caso de error.
	
	\item[player\_state (file) : \textit{enum}]
	Indica el estado actual del planificador. Tales estados se detallan en el apartado siguiente.
	
	\begin{description}
		\item[file : \textit{string}] Es un parámetro de salida, sobre él se escribe el nombre del archivo que se estaba reproduciendo. Solo es válido si el reproductor está activo o en pausa.
	\end{description}
	
	Devuelve el estado actual del reproductor, a saber entre los estados contemplados en la máquina.
	
	\item[player\_engineer\_enter () : \textit{dword}]
	Detiene el reproductor, bloquea el planificador y entra en modo Ingeniería. Devuelve 0 en caso de éxito o -1 en caso de error, como estar ya dentro del modo Ingeniería.
	
	\item[player\_engineer\_exit () : \textit{dword}]
	Sale del modo Ingeniería y debloquea el planificador. Devuelve 0 en caso de éxito o -1 en caso de error, como no estar dentro del modo Ingeniería.
	
\end{description}

\subsubsection{Máquina de estados}

Para gestionar su funcionamiento, el planificador utiliza una pequeña cantidad de estados, que mostramos a continuación:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/sched}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:sched} Diagrama de estados del planificador.}
\end{figure} 

\smallskip

\begin{description}
	\item[Activo] En funcionamiento, reproduciendo activamente una partitura.
	\item[Pausado] No reproduce, mantiene el estado del órgano en el módulo de salida.
	\item[Parado] En espera. Es el estado inicial.
	\item[Ingeniero] Bloqueado, en modo Ingeniería. Ha cedido el control del módulo de salida.
\end{description}

\subsubsection{Algoritmo básico}

Para que todas las pistas se ejecuten simultáneamente, el planificador recorre en cada ciclo todas las listas, avanzando mientras sea el momento de ejecutar el evento correspondiente ($\Delta=0$). Cuando se ha llegado a un evento con $\Delta > 0$ en todas las pistas, se busca el menor valor y se resta a todos los \textit{deltas}. A continuación, se solicita al sistema operativo la espera correspondiente al tiempo restado, y se repite el ciclo. El algoritmo termina cuando todas las pistas han llegado al final.

\begin{algorithmic}
	\LOOP
		\STATE $mindelta \gets \infty$
		\STATE $i\gets 0$
		\WHILE {$i < n_{tracks}$}
			\WHILE {$event_i.delta = 0$ \AND \NOT ($event_i.type = METAEVENT$ \AND \\ $event_i.metaevent.type = END\_OF\_TRACK$)}
				\IF {$event_i.type = NOTE\_ON$}
					\STATE $output\_noteon(i, event_i.param1)$
				\ELSE 
					\IF {$event_i.type = NOTE\_OFF$}
						\STATE $output\_noteoff (i, event_i.param1)$
					\ENDIF
				\ENDIF
				\STATE $event_i \gets event_i.next$
			\ENDWHILE
			\IF {$event_i.delta > 0$ \AND $event_i.delta < mindelta$}
				\STATE $mindelta \gets event_i.delta$
			\ENDIF
		\ENDWHILE
		\STATE $i \gets 0$
		
		\WHILE {$i < n_{tracks}$}
			\STATE $event_i.delta \gets event_i.delta - min$
		\ENDWHILE
		\STATE $sleep (mindelta)$
	\ENDLOOP
\end{algorithmic}

\subsubsection{Diagrama de uso}

Como parte central del programa, y al contrario que el resto de componentes, el planificador está conectado con la mayoría de módulos, actuando como mediador y coordinador entre aquellos que reciben órdenes y los que facilitan la salida de información.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_scheduler}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_scheduler} Diagrama de uso del planificador.}
\end{figure} 

\smallskip

\begin{itemize}
	\item Los servidores de \textit{socket} y de \textit{UART}, y el control de interfaz reducida, envían las órdenes de control.
	\item El módulo \textit{MIDI} es utilizado para descodificar los archivos de entrada.
	\item La información extraída se dirige al módulo de salida (\textit{GPIO}) para llegar a la \textit{PCB}.
\end{itemize}

\subsection{Modo Ingeniería}

El sistema requiere un modo de mantenimiento para regular la mecánica, al que se accederá localmente, a través de una interfaz reducida que controlaremos con el codificador rotatorio y el \textit{LCD}.

El codificador permitirá acceder al modo Ingeniería, que detendrá la reproducción ---si estaba en funcionamiento--- y  aislará el planificador, ganando acceso directo a la salida \textit{GPIO}.

Vamos a diseñar la interfaz como una máquina de estados: Inicialmente el modo Ingeniería está desactivado, girando el botón se nos dará la opción de activarlo, y al pulsarlo entraremos en él. Se activará la nota más baja de la primera pista, al girar el botón podremos movernos cíclicamente por todas las notas de esa pista. Pulsando el botón cambiamos a la segunda pista, luego a la tercera, y así hasta la última. Si apretamos nuevamente el botón, volvemos al menú que nos permitirá salir del modo Ingeniería.

Este diagrama muestra las transiciones entre los estados:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo4/engineer}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:engineer} Máquina de estados de la interfaz reducida.}
\end{figure} 

\smallskip

\begin{description}
	\item[OFF] Estado inicial, modo Ingeniería apagado. Mostrará el estado del reproductor.
	\item[MENU] Ofrece la opción de entrar en el modo Ingeniería.
	\item[ON] Modo Ingeniería activado, los subestados dependen de la pista y la nota actuales
\end{description}

\subsubsection{Diagrama de uso}

El módulo que controla el modo Ingeniería interacciona con el planificador, para detenerlo y aislarlo del \textit{GPIO}, y con el módulo de salida, que maneja el propio \textit{GPIO}, para manipular el estado.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_engineer}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_engineer} Diagrama de uso del modo Ingeniería.}
\end{figure} 

\smallskip

\subsection{Salida hacia la PCB}

El reproductor delega en el módulo de salida las siguientes funciones:

\begin{enumerate}
	\item Dirigir las pistas de \textit{MIDI} al canal de salida correspondiente.
	\item Almacenar el estado de salida (notas pulsadas y no pulsadas).
	\item Volcar la información en el \textit{GPIO}.
\end{enumerate}

Éste será el único módulo que tendremos que cambiar a la hora de pasar de un órgano a otro. El hecho de aislar la salida también nos da flexibilidad para sustituir la interfaz \textit{GPIO} por otro tipo de salida, como la consola, con fines de mantenimiento y depuración.

Las siguientes funciones conforman la interfaz del módulo:

\begin{description}[style=nextline]
	\item[output\_init () : \textit{dword}]
	Inicializa los componentes de la salida. Devuelve 0 en caso de éxito o -1 en caso de error.
	
	\item[output\_destroy ()]
	Cierra el módulo de salida y libera la memoria ocupada.
	
	\item[output\_noteon (track, note)]
	Marcar una nota para activar en el sistema.
	
	\begin{description}
		\item[track : \textit{dword}] Índice de la pista \textit{MIDI}.
		\item[note : \textit{dword}] Número de nota \textit{MIDI}.
	\end{description}
	
	\item[output\_noteon (track, note)]
	Marcar una nota para apagarla en el sistema.
	
	\begin{description}
		\item[track : \textit{dword}] Índice de la pista \textit{MIDI}.
		\item[note : \textit{dword}] Número de nota \textit{MIDI}.
	\end{description}
	
	\item[output\_update ()]
	Vuelca el estado en la salida.
	
	\item[output\_panic ()]
	Vuelve al estado inicial (silenciar todas las notas), y lo vuelca en la salida.
	
	\item[output\_silence ()]
	Silencia todas las notas en la salida, pero mantiene el estado. Útil para pausar la reproducción.
	
\end{description}

\subsubsection{Mapeo de pistas y canales}

Nuestra especificación deja abierta la estructura que pueda tener un archivo MIDI. A pesar de que el sistema podrá descodificar \textit{MIDI} estándar, para lograr una óptima ejecución, la pieza deberá adaptarse a cada órgano concreto.

El módulo de salida permitirá asignar cada pista \textit{MIDI}, que normalmente corresponde a un pentagrama de la partitura, a un canal de salida diferente. La asignación por defecto, para el órgano estudiado, será la siguiente:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/3]{capitulo4/map}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:map} Asignación de pistas \textit{MIDI} y canales de salida.}
\end{figure} 

\smallskip

\subsubsection{Diagrama de uso}

La interfaz de salida es utilizada principalmente por el planificador y, solo cuando éste entra en modo Ingeniería, es accedida por el módulo del mismo nombre, para poner a prueba la mecánica del sistema.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/daemon_gpio}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:daemon_gpio} Diagrama de uso del módulo de salida.}
\end{figure} 

\smallskip

\subsection{Seguridad}

A pesar de que el acceso al sistema se hará siempre con autentificación de usuario, nos interesa controlar que no todos los usuarios, o no todas las aplicaciones, se conecten al \textit{socket}. La seguridad de \textit{Linux} recae en gran parte sobre su sistema de archivos y permisos. Se creará un nombre de usuario de sistema para ser utilizado exclusivamente por el \textit{socket}, que tendrá permisos de lectura y escritura para dicho usuario y su grupo.

Para autorizar a un usuario a acceder al \textit{socket}, simplemente hay que añadirlo al grupo del usuario propietario.

Por otro lado, el demonio se ejecuta con permisos de \textit{superusuario}, y es inseguro mantenerse durante toda la ejecución con tales privilegios. A pesar de que introduciremos medidas de seguridad en los clientes que desarrollemos para el sistema, reduciremos los permisos después de inicializar el proceso, como medida adicional para evitar problemas.

\section{Base de datos}

La información que queremos almacenar funciona de la siguiente forma:

\begin{enumerate}
	\item Las partituras se guardan en un archivo, cuyo nombre no tiene que coincidir con el título de la partitura.
	\item De una partitura podremos conocer su duración.
	\item Una lista de reproducción es una colección de partituras, y le asignaremos un nombre.
	\item Cada partitura pertenecerá a una lista de reproducción, y solo a una.
	\item Un botón se distingue por su código, y se le asigna a una lista de reproducción, sin perjuicio de que una lista esté asignada a varios botones. Naturalmente, puede haber listas que no estén asignadas a ningún botón.
\end{enumerate}

\subsection{Modelo entidad-relación}

Atendiendo a los requisitos propuestos, modelamos nuestros datos según el siguiente diagrama:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo4/bd_er}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:bd_er} Modelo entidad-relación.}
\end{figure} 

\smallskip

\subsection{Modelo relacional}

Una vez hemos considerado las entidades, sus atributos y las relaciones, diseñamos el modelo de datos, que depende del tipo de sistema de gestión de bases de datos ---\textit{DBMS (database management system)}--- que vayamos a utilizar. En nuestro caso, utilizaremos un \textit{DBMS} relacional.

\begin{enumerate}
	\item Convertimos en relaciones (tablas) todas las entidades y las relaciones del modelo entidad-relación.
	\item Los atributos de las entidades pasan a ser atributos de las relaciones correspondientes.
	\item Buscamos llaves candidatas y escogemos una como llave primaria. En el caso de Pieza y Lista, no tenemos llave candidata, así que añadimos un ID a cada relación.
	\item Las relaciones Contiene y Asigna tienen cardinalidad N-1, de forma que comparten la clave primaria. Fusionamos Contiene en Pieza y Asigna en Botón.
\end{enumerate}

Una vez hecho esto, el modelo resultante es el siguiente:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[clip=true, trim=390 340 390 340, width=\linewidth*3/4]{capitulo4/bd_rel}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:bd_rel} Modelo relacional.}
\end{figure} 

\smallskip

\subsection{Consistencia}

Para garantizar que la base de datos mantendrá la información coherente y sin anomalías, estudiamos las relaciones para normalizarlas. Podemos verificar que nuestro modelo relacional está en 5ª forma normal, atendiendo a las siguientes condiciones:

\begin{description}
	\item[1FN] El \textit{SGBD} relacional se encarga de que se cumpla la forma normal más básica: las columnas son regulares, no habrá filas duplicadas (por la llave primaria) ni orden alguno entre filas o columnas.
	\item[2FN] Todos los atributos secundarios de cada tabla dependen de la llave primaria, por tanto, está en segunda forma normal.
	\item[3FN] No existen atributos secundarios que dependan transitivamente de la llave primaria, entonces, está en tercera forma normal.
	\item[FNBC] La forma normal de Boyce-Codd establece que los únicos determinantes sean las claves candidatas. Como el modelo está en 3FN y no existen llaves candidatas compuestas, podemos decir que está también en 3FN.
	\item[4FN] La cuarta forma normal extiende la FNBC exigiendo que no existan dependencias multivaluadas no triviales. Este modelo no tiene dependencias multivaluadas, de forma que está en 4FN.
	\item[5FN] Por último, la quinta forma normal especifica que, además de todo lo anterior, cada dependencia de unión sea implicada por claves candidatas. Esto se cumple en nuestro modelo, ya que toda llave externa se vincula a la llave primaria de otra relación.
\end{description}

Nuestro modelo relacional cumple todas las exigencias de las formas normales tenidas en cuenta, con lo que podemos garantizar que el modelo es consistente.

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/bd_fn}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:bd_fn} Relación entre las formas normales.}
\end{figure} 

\smallskip

\section{Control remoto}

Hasta ahora hemos diseñado el \textit{back-end} del sistema, con todas las características que darán funcionalidad a nuestra solución. Pero aún no tenemos una interfaz que permita al usuario interactuar con el sistema, más que el control del mando a distancia o desde la \textit{PCB}.

El próximo paso es concebir el \textit{front-end} que, a tenor de los requisitos que propusimos al inicio, ofrezca al usuario la interfaz más completa posible. Frecuentemente la funcionalidad viene contrapuesta a la facilidad de uso; es nuestra tarea encontrar el mejor equilibrio posible.

Vamos a diseñar una solución enfocada al uso remoto con ayuda de un explorador de Internet, como \textit{Chrome}, \textit{Firefox} o \textit{Safari}, con lo que crearemos un servidor \textit{web}. El control del órgano queda pues estructurado de la siguiente forma:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*2/3]{capitulo4/despliegue}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:despliegue} Comunicación entre el cliente y el software del sistema.}
\end{figure} 

\smallskip

En primer lugar será especificar los casos de uso que nos enfrentarán al usuario. Después, concebiremos el aspecto de la interfaz y por último esbozaremos la estructura del diseño.

\subsection{Casos de uso}

A continuación enumeramos una relación de casos de uso que deberá cubrir la interfaz de usuario:

\begin{enumerate}
	\item Identificarse en el sistema como usuario autorizado.
	\item Salir del sistema, en el sentido de que al entrar de nuevo haya que identificarse.
	\item Controlar la reproducción directamente, a saber:
	
	\begin{enumerate}
		\item Ver el nombre de la pieza que se está reproduciendo.
		\item Ejecutar una lista de reproducción en bucle.
		\item Escoger una pieza de la lista para reproducirla.
		\item Pausar la reproducción de una pieza.
		\item Reanudar la ejecución de una pieza, si estaba pausada.
		\item Detener completamente la reproducción.
		\item Avanzar en la lista y reproducir la siguiente pieza.
		\item Retroceder en la lista y reproducir la partitura anterior.
	\end{enumerate}
	
	\item Gestionar listas de reproducción:
	
	\begin{enumerate}
		\item Crear una nueva lista, dándole un nombre.
		\item Visualizar todas las listas existentes.
		\item Modificar el nombre de la lista.
		\item Eliminar una lista.
	\end{enumerate}
	
	\item Gestionar piezas musicales:
	
	\begin{enumerate}
		\item Cargar una nueva partitura en el sistema, dentro de una lista de reproducción.
		\item Ver una relación de las piezas contenidas en una lista, y su duración.
		\item Cambiar el nombre de una pieza.
		\item Borrar una pieza del sistema.
	\end{enumerate}
	
	\item Gestionar asignaciones de botones del mando:
	
	\begin{enumerate}
		\item Ver las asignaciones actuales.
		\item Cambiar la lista a reproducir cuando se pulsa un botón, escogiéndola entre todas las listas.
	\end{enumerate}
	
	\item Controlar básicamente la energía del sistema:
	
	\begin{enumerate}
		\item Apagar el sistema.
		\item Reiniciar el sistema.
	\end{enumerate}
	
	\item Escoger el idioma en que se muestra el texto, entre una lista de lenguas disponibles.
\end{enumerate}

\subsection{Modelo-vista-controlador}

Para estructurar los elementos que conformarán la interfaz, utilizaremos el patrón de modelo-vista-controlador, que divide la funcionalidad de un sistema en tres bloques, con el siguiente criterio:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/mvc}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:mvc} Relación entre la vista, el modelo y el controlador.}
\end{figure} 

\smallskip

\begin{description}
	\item[Vista] Reúne los elementos que van a proporcionar al usuario la información que requiere.
	\item[Controlador] Comprende los módulos a los que el usuario acudirá para manipular el sistema. Eventualmente, después de realizar una operación, puede llamar a la vista para realimentar de información al usuario. 
	\item[Modelo] Contiene los componentes más internos, abstrayendo a la vista y al controlador de la representación de los datos o la interacción con el sistema.
\end{description}

Considerando los casos de uso y los requisitos, hemos enmarcado en el esquema modelo-vista-controlador los siguientes elementos:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*2/3]{capitulo4/mvc_completo}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:mvc_completo} Módulos que componen el sistema.}
\end{figure} 

\smallskip

A lo largo de esta sección detallaremos el comportamiento de todos los componentes.

\subsection{Estilo de la interfaz}

La visualidad es un punto importante en el diseño de interfaces gráficas, es la encargada de proporcionar una experiencia de usuario y hacer asequible la utilización del sistema. Pretendemos entregar la información requerida de forma clara y concisa, disponer fácilmente de los controles que puedan ser necesarios en cada vista, y que el estilo sea agradable y acorde a la solución que se está diseñando.

Por ello, vamos a fijarnos en la guía de estilo \textit{Material Design} de \textit{Google} para inspirarnos. La idea es sencilla: cada elemento de la interfaz se entiende como una hoja de papel. El diseñador maquetará la interfaz en base a hojas que se solapan, produciendo una sutil sombra cuando esto ocurre.

\textit{Material design} provee una gran cantidad de componentes de control y paletas de colores. De todos ellos, escogeremos listas, menús desplegables y botones flotantes. Nos decantamos por un color marrón, que evoca tranquilidad y estabilidad, dando idea de un \textit{software} intuitivo y robusto.

Una vez dibujados los primeros trazos, no es necesario maquetar completamente la interfaz con una aplicación para manipular imágenes, pudiendo diseñar las vistas en \textit{HTML} y \textit{CSS}, aún sin código de programación. Pero es muy útil dibujar al menos una página que nos sirva de plantilla. La siguiente imagen es una primera versión de la maqueta, diseñada con \textit{Adobe Photoshop}:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth*3/4]{capitulo4/maqueta}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:maqueta} Maquetación de las capas.}
\end{figure}

\smallskip

\subsection{Portada}

La portada es la vista principal y va a cumplir dos funciones:

\begin{enumerate}
	\item Presentar la aplicación y dar la bienvenida.
	\item Introducir una contraseña para acceder al sistema.
\end{enumerate}

La vista proporcionará un fondo dinámico, con varias imágenes temáticas, y un cuadro para introducir la contraseña. Al hacerlo, se enviará al controlador, que se ocupará de verificar que la clave es correcta y concederá el acceso al reproductor.

\subsubsection{Autentificación}

El módulo de autentificación recibe la contraseña introducida por el usuario, y utiliza la interfaz del modelo para validarla.

La contraseña será la de un usuario (a especificar) del sistema Linux, que provee una forma segura de almacenar contraseñas cifradas y gestionar usuarios. La verificación no se hará directamente, sino que llamaremos a un programa externo, que describiremos más abajo, para que haga tal trabajo.

El resto de vistas y controladores de la interfaz deberán consultar si se ha iniciado sesión antes de proceder a realizar la petición correspondiente. Cuando un usuario accede al sistema con una contraseña válida, se guardará una marca en su sesión para no tener que introducirla en cada vista.

Definiremos las siguientes funciones:

\begin{description}[style=nextline]
	\item[login (password)]
	Comprueba la contraseña llamando a una aplicación que diseñaremos específicamente.
	
	\begin{description}
		\item[password] Clave introducida por el usuario.
	\end{description}
	
	Si la contraseña es correcta, marca la autorización en la sesión y redirige a la vista del Reproductor. Si no, redirige a la portada y muestra un mensaje de error.
	
	\item[logout ()]
	Cierra la sesión retirando la marca de autorización de la sesión. Redirige a la portada.
	
\end{description}

A continuación mostramos el diagrama de uso de la vista de portada y el módulo de acceso:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/mvc_acceso}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:mvc_acceso} Módulos implicados en el acceso al sistema.}
\end{figure} 

\smallskip

\subsection{Reproductor}

El reproductor es la parte fundamental de la interfaz. Mostrará los siguientes elementos:

\begin{enumerate}
	\item Estado del demonio (reproduciendo, pausado o detenido).
	\item Nombre de la pieza que se está ejecutando (si procede).
	\item Lista de reproducción activa (si procede).
	\item Controles de reproducción:
	
	\begin{enumerate}
		\item Pausar.
		\item Reanudar.
		\item Detener.
		\item Siguiente pieza.
		\item Pieza anterior.
	\end{enumerate}
\end{enumerate}

Hay que tener en cuenta que el protocolo de comunicación establece que el reproductor del demonio no es consciente de la lista de reproducción en la base de datos. Al ordenar una reproducción se le envía los nombres de archivo, como se describe en la función \textit{player\_playlist()} del demonio. De igual forma, al consultar el estado, devuelve el nombre de la pieza que se está ejecutando, cuya lista se puede conocer por reunión natural en la base de datos, y si no se encuentra, es porque se está reproduciendo un archivo externo, o tal vez otro usuario la ha eliminado.

Esto se hace así para evitar mantener un estado común entre el demonio y la interfaz, que podría provocar incoherencias si el cliente se desconecta repentinamente o si hay varios usuarios conectados al mismo tiempo.

Se definirán las siguientes funciones:

\begin{description}[style=nextline]
	\item[play (idplaylist, idscore)]
	Reproduce en bucle la lista indicada, empezando por la pieza especificada.
	
	\begin{description}
		\item[idplaylist] ID de la lista en la base de datos.
		\item[idscore] (opcional) ID de la primera pieza a reproducir.
	\end{description}
	
	Redirige a la vista del Reproductor.
	
	\item[pause ()]
	Pausa la reproducción de la partitura.
	
	\item[resume ()]
	Reanuda la ejecución de la pieza.
	
	\item[stop ()]
	Detiene completamente la reproducción en el demonio.
	
\end{description}

El reproductor interacciona con el resto de la interfaz según este esquema:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/mvc_reproductor}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:mvc_reproductor} Módulos implicados en el reproductor.}
\end{figure} 

\smallskip

\subsection{Gestión de listas de reproducción}

Una parte importante de la interfaz es facilitar la organización de la información. Las piezas musicales se clasificarán en listas de reproducción. Este módulo agrega la funcionalidad necesaria para gestionar listas.

El gestor se presentará con los siguientes controles:

\begin{enumerate}
	\item Lista de listas de reproducción, con el siguiente contenido:

	\begin{enumerate}
		\item Nombre de la lista.
		\item Número de piezas contenidas.
		\item Vínculo para acceder a la lista.
		\item Vínculo para ejecutar la lista en el reproductor.
	\end{enumerate}
	
	\item Botón para crear una nueva lista. Al dispararlo, abrirá un cuadro de diálogo para introducir el nombre de la lista.
	
\end{enumerate}

El controlador tendrá las siguientes funciones:

\begin{description}[style=nextline]
	\item[new\_playlist (name)]
	Genera una lista nueva, con el nombre que se recibe. 
	
	\begin{description}
		\item[name] Nombre que identificará a la nueva lista.
	\end{description}
	
	Redirige al administrador de la nueva lista.
	
	\item[rename\_playlist (idplaylist, name)]
	Cambia el nombre de una lista existente.
	
	\begin{description}
		\item[idplaylist] ID de la lista en la base de datos.
		\item[name] Nuevo nombre a asignar a la lista.
	\end{description}
	
	Redirige al administrador de la lista.
	
	\item[delete\_playlist (idplaylist)]
	Elimina una lista de reproducción y todas las partituras que contenga.
	
	\begin{description}
		\item[idplaylist] ID de la lista en la base de datos.
	\end{description}
	
	Redirige al gestor de listas de reproducción.
	
\end{description}

Los componentes implicados en la gestión de listas se relacionan de la siguiente forma:

\smallskip

\begin{figure}[H]
	\noindent \begin{centering}
		\includegraphics[width=\linewidth/2]{capitulo4/mvc_listas}
		\par\end{centering}
	\smallskip
	\caption{\label{fig:mvc_listas} Módulos implicados en el gestor de listas.}
\end{figure} 

\smallskip

\subsection{Gestión de partituras}





\subsection{Asignación del mando a listas}

\subsection{Control de energía}

\subsection{Soporte de idiomas}

\subsection{Navegación}

\subsection{Sesión}

\subsection{Comunicación con el demonio}

\subsection{Comunicación con la base de datos}

\section{Protocolo entre el control y el demonio}

\section{Aplicaciones auxiliares}

\subsection{Terminal del reproductor}

\subsection{Información de archivo MIDI}

\subsection{Comprobación de contraseña}

\clearpage{\cleardoublepage}
\clearpage{\pagestyle{empty}\cleardoublepage}